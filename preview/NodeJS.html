<html>
  <head>
	  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>NodeJS</title>
		<link href="toc/style/github-bf51422f4bb36427d391e4b75a1daa083c2d840e.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/style/github2-d731afd4f624c99a4b19ad69f3083cd6d02b81d5.css" media="all" rel="stylesheet" type="text/css"/>
    <link href="toc/css/zTreeStyle/zTreeStyle.css" media="all" rel="stylesheet" type="text/css"/>
    <link rel="shortcut icon" href="favicon.ico" />
  <script src="../js/review.js"></script>
	  <style>
		pre {
		    counter-reset: line-numbering;
		    border: solid 1px #d9d9d9;
		    border-radius: 0;
		    background: #fff;
		    padding: 0;
		    line-height: 23px;
		    margin-bottom: 30px;
		    white-space: pre;
		    overflow-x: auto;
		    word-break: inherit;
		    word-wrap: inherit;
		}

		pre a::before {
		  content: counter(line-numbering);
		  counter-increment: line-numbering;
		  padding-right: 1em; /* space after numbers */
		  width: 25px;
		  text-align: right;
		  opacity: 0.7;
		  display: inline-block;
		  color: #aaa;
		  background: #eee;
		  margin-right: 16px;
		  padding: 2px 10px;
		  font-size: 13px;
		  -webkit-touch-callout: none;
		  -webkit-user-select: none;
		  -khtml-user-select: none;
		  -moz-user-select: none;
		  -ms-user-select: none;
		  user-select: none;
		}

		pre a:first-of-type::before {
		  padding-top: 10px;
		}

		pre a:last-of-type::before {
		  padding-bottom: 10px;
		}

		pre a:only-of-type::before {
		  padding: 10px;
		}

		.highlight { background-color: #ffffcc } /* RIGHT */
		</style>
  </head>
  <body>
	  <div>
				<div style='width:25%;'>
						<ul id="tree" class="ztree" style='width:100%'>

						</ul>
				</div>
        <div id='readme' style='width:70%;margin-left:20%;'>
          	<article class='markdown-body'>
            	<h1 id="nodejs-">nodejs基本介绍</h1>
<h2 id="-nodejs">为什么要学习nodejs</h2>
<p>为什么要学习服务端的开发？</p>
<ol>
<li>通过学习Node.js开发理解<strong>服务器开发</strong>、<strong>Web请求和响应过程</strong>、 <strong>了解服务器端如何与客户端配合</strong></li>
<li>作为前端开发工程师（FE）需要具备一定的服务端开发能力</li>
<li>全栈工程师的必经之路</li>
</ol>
<p>服务器端开发语言有很多，为什么要选择nodejs</p>
<ol>
<li>降低编程语言切换的成本(nodejs实质上用的还是javascript)</li>
<li>NodeJS是前端项目的基础设施，前端项目中用到的大量工具 (大前端)</li>
<li>nodejs在处理高并发上有得天独厚的优势</li>
<li><p><strong>对于前端工程师，面试时对于nodejs有一定的要求</strong></p>
</li>
<li><p><a href="https://www.zhipin.com/job_detail/d35a590c832162ed1XB42Ny-Flo~.html?ka=search_list_7">web前端10-20k</a></p>
</li>
<li><a href="https://www.zhipin.com/job_detail/fa90a3f6c28712da1XF-2dm5FVc~.html?ka=search_list_15">web前端15-30k</a></li>
</ol>
<h2 id="node-js-">node.js 是什么？</h2>
<p>node.js，也叫作node，或者nodejs，指的都是一个东西。</p>
<ol>
<li><a href="https://nodejs.org/">node.js官方网站</a></li>
<li><a href="http://nodejs.cn/">node.js中文网</a></li>
<li><a href="https://cnodejs.org/">node.js 中文社区</a></li>
</ol>
<p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境，nodejs允许javascript代码运行在服务端</p>
<pre><code>1. nodejs不是一门新的编程语言，nodejs是在服务端运行javascript的运行环境
2. 运行环境：写得程序想要运行必须要有对应的运行环境
    php代码必须要有apache服务器
    在web端，浏览器就是javascript的运行环境
    在node端，nodejs就是javascript的运行环境
2. javascript并不只是能运行在浏览器端，浏览器端能够运行js是因为浏览器有js解析器，因此只需要有js解析器，任何软件都可以运行js。
3. nodejs可以在服务端运行js，因为nodejs是基于chrome v8的js引擎。
</code></pre><p><strong>nodejs的本质：不是一门新的编程语言，nodejs是javascript运行在服务端的运行环境，编程语言还是javascript</strong></p>
<h2 id="nodejs-">nodejs与浏览器的区别</h2>
<p>相同点：nodejs与浏览器都是浏览器的运行环境，都能够解析js程序。对于ECMAScript语法来说，在nodejs和浏览器中都能运行。</p>
<p>不同点：nodejs无法使用DOM和BOM的操作，浏览器无法执行nodejs中的文件操作等功能</p>
<p><img src="E:/work/node/imgs/nodejs.png" alt=""></p>
<p>思考：</p>
<ol>
<li>在浏览器端，可以使用javascript操作文件么？</li>
<li>在nodejs端，可以使用BOM和DOM的方法么？</li>
<li>我们学习nodejs，学习什么内容？ </li>
</ol>
<h2 id="nodejs-">nodejs可以干什么？</h2>
<ol>
<li>开发服务端程序</li>
<li>开发命令行工具（CLI），比如npm,webpack,gulp,less,sass等 vue-cli</li>
<li>开发桌面应用程序（借助 node-webkit、electron 等框架实现）</li>
</ol>
<h1 id="-nodejs">安装nodejs</h1>
<h2 id="nodejs-">nodejs版本</h2>
<p>下载地址</p>
<ul>
<li><a href="https://nodejs.org/en/download/">当前版本</a></li>
<li><a href="https://nodejs.org/en/download/releases/">历史版本</a></li>
</ul>
<p>官网术语解释</p>
<ul>
<li>LTS 版本：Long-term Support 版本，长期支持版，即稳定版。</li>
<li>Current 版本：Latest Features 版本，最新版本，新特性会在该版本中最先加入。</li>
</ul>
<p>查看node版本</p>
<pre><code class="lang-bash">node -v
</code></pre>
<h1 id="-nodejs-">运行nodejs程序</h1>
<ul>
<li>创建js文件 <code>helloworld.js</code></li>
<li>写nodejs的内容：<code>console.log(&#39;hello nodejs&#39;)</code></li>
<li>打开命令窗口 <code>cmd</code><ul>
<li>shift加右键打开命令窗口，执行 <code>node 文件名.js</code>即可</li>
<li>给vscode安装<code>terminal</code>插件，直接在vscode中执行</li>
</ul>
</li>
<li>执行命令：<code>node helloworld.js</code></li>
</ul>
<p>注意：在nodejs中是无法使用DOM和BOM的内容的，因此<code>document, window</code>等内容是无法使用的。</p>
<h1 id="global-">global模块-全局变量</h1>
<blockquote>
<p>Node.js 中的全局对象是 <code>global</code>, 类似于浏览器中的<code>window</code></p>
</blockquote>
<p>常用的global属性</p>
<pre><code class="lang-javascript">//Ctrl+C 停止终端代码运行
//cls或者clear 清空终端代码
console: 用于打印日志
setTimeout/clearTimeout: 设置清除延时器
setInterval/clearInterval: 设置清除定时器

//获取的都是决定路径
__dirname: 当前文件的路径，不包括文件名（目录路径）
__filename： 获取当前文件的路径，包括文件名（文件路径）

//与模块化相关的，模块化的时候会用到
require
exports
module
</code></pre>
<h1 id="fs-">fs文件系统模块</h1>
<blockquote>
<p>fs模块是nodejs中最常用的一个模块，因此掌握fs模块非常的有必要，fs模块的方法非常多,用到了哪个查哪个即可。</p>
<p>文档地址：<a href="http://nodejs.cn/api/fs.html">http://nodejs.cn/api/fs.html</a></p>
</blockquote>
<p>  在nodejs中，提供了fs模块，这是node的核心模块</p>
<p>  注意：</p>
<ol>
<li>除了global模块中的内容可以直接使用，其他模块都是需要加载的。</li>
<li>fs模块不是全局的，不能直接使用。因此需要导入才能使用。</li>
</ol>
<pre><code class="lang-javascript">var fs = require(&quot;fs&quot;);
</code></pre>
<h2 id="-">读取文件</h2>
<blockquote>
<p>语法：fs.readFile(path[, options], callback)</p>
</blockquote>
<p>方式一：不传编码参数（可以读取图片、视频、音频）</p>
<pre><code class="lang-javascript">//参数1： 文件的路径
//参数2： 读取文件的回调函数
  //参数1：错误对象，如果读取失败，err会包含错误信息，如果读取成功，err是null
  //参数2：读取成功后的数据（是一个Buffer对象，内部二进制的，需要使用toString转成字符串）

fs.readFile(&quot;data.txt&quot;, function(err, data){
  console.log(err);
  console.log(data);
});
</code></pre>
<p>方式二：传编码参数（读取文本内容）</p>
<pre><code class="lang-javascript">//参数1： 文件的路径
//参数2： 编码，如果设置了，返回一个字符串，如果没有设置，会返回一个buffer对象
//参数3： 回调函数
fs.readFile(&quot;data.txt&quot;, &quot;utf8&quot;,function(err, data){
  console.log(err);
  console.log(data);
});
</code></pre>
<p>关于Buffer对象</p>
<pre><code class="lang-javascript">1. Buffer对象是Nodejs用于处理二进制数据的。
2. 其实任意的数据在计算机底层都是二进制数据，因为计算机只认识二进制。
3. 所以读取任意的文件，返回的结果都是二进制数据，即Buffer对象
4. Buffer对象可以调用toString()方法转换成字符串。
</code></pre>
<h2 id="-">写文件</h2>
<blockquote>
<p>语法：fs.writeFile(file, data[, options], callback)</p>
</blockquote>
<pre><code class="lang-javascript">//参数1：写入的文件名(如果文件不存在，会自动创建)
//参数2：写入的文件内容（注意：写入的内容会覆盖以前的内容）
//参数3：写文件后的回调函数
fs.writeFile(&quot;2.txt&quot;, &quot;hello world, 我是一个中国人&quot;, function(err){
  if(err) {
    return console.log(&quot;写入文件失败&quot;, err);
  }
  console.log(&quot;写入文件成功&quot;);
});
</code></pre>
<p>拓展：<strong>throw</strong> 抛出错误，中断代码不再向下执行，工作中配合try与catch使用</p>
<pre><code class="lang-js">try{
    //错误代码
}catch(e){
    //捕获错误代码
    //可以发送邮件或者其它智能设备给工程师
}
</code></pre>
<p>注意：</p>
<ol>
<li>写文件的时候，会把原来的内容给覆盖掉</li>
</ol>
<h2 id="-">追加文件</h2>
<blockquote>
<p>语法：fs.appendFile(path, data[, options], callback)</p>
</blockquote>
<pre><code class="lang-javascript">//参数1：追加的文件名(如果文件不存在，会自动创建)
//参数2：追加的文件内容
//参数3：追加文件后的回调函数
fs.appendFile(&quot;2.txt&quot;, &quot;我是追加的内容&quot;, function(err){
  if(err) {
    return console.log(&quot;追加文件内容失败&quot;);
  }
  console.log(&quot;追加文件内容成功&quot;);
})
</code></pre>
<p>思考：如果没有appendFile，通过readFile与writeFile应该怎么实现？</p>
<h2 id="-">文件同步与异步的说明</h2>
<blockquote>
<p>fs中所有的文件操作，都提供了异步和同步两种方式</p>
</blockquote>
<p>异步方式：不会阻塞代码的执行</p>
<pre><code class="lang-javascript">//异步方式
var fs = require(&quot;fs&quot;);

console.log(111);
fs.readFile(&quot;2.txt&quot;, &quot;utf8&quot;, function(err, data){
  if(err) {
    return console.log(&quot;读取文件失败&quot;, err);
  }
  console.log(data);
});
console.log(&quot;222&quot;);
</code></pre>
<p>同步方式：会阻塞代码的执行</p>
<pre><code class="lang-javascript">//同步方式
console.log(111);
var result = fs.readFileSync(&quot;2.txt&quot;, &quot;utf-8&quot;);
console.log(result);
console.log(222);
</code></pre>
<p>总结：同步操作使用虽然简单，但是会影响性能，因此尽量使用异步方法，尤其是在工作过程中。</p>
<h2 id="-api-">其他api（了解）</h2>
<p>方法有很多，但是用起来都非常的简单，学会查文档</p>
<p>文档：<a href="http://nodejs.cn/api/fs.html">http://nodejs.cn/api/fs.html</a></p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>fs.readFile(path, callback)</code></td>
<td>读取文件内容（异步）</td>
</tr>
<tr>
<td><code>fs.readFileSync(path)</code></td>
<td>读取文件内容（同步）</td>
</tr>
<tr>
<td><code>fs.writeFile(path, data, callback)</code></td>
<td>写入文件内容（异步）</td>
</tr>
<tr>
<td><code>fs.writeFileSync(path, data)</code></td>
<td>写入文件内容（同步）</td>
</tr>
<tr>
<td><code>fs.appendFile(path, data, callback)</code></td>
<td>追加文件内容（异步）</td>
</tr>
<tr>
<td><code>fs.appendFileSync(path, data)</code></td>
<td>追加文件内容（同步）</td>
</tr>
<tr>
<td><code>fs.rename(oldPath, newPath, callback)</code></td>
<td>重命名文件（异步）</td>
</tr>
<tr>
<td><code>fs.renameSync(oldPath, newPath)</code></td>
<td>重命名文件（同步）</td>
</tr>
<tr>
<td><code>fs.unlink(path, callback)</code></td>
<td>删除文件（异步）</td>
</tr>
<tr>
<td><code>fs.unlinkSync(path)</code></td>
<td>删除文件（同步）</td>
</tr>
<tr>
<td><code>fs.mkdir(path, mode, callback)</code></td>
<td>创建文件夹（异步）</td>
</tr>
<tr>
<td><code>fs.mkdirSync(path, mode)</code></td>
<td>创建文件夹（同步）</td>
</tr>
<tr>
<td><code>fs.rmdir(path, callback)</code></td>
<td>删除文件夹（异步）</td>
</tr>
<tr>
<td><code>fs.rmdirSync(path)</code></td>
<td>删除文件夹（同步）</td>
</tr>
<tr>
<td><code>fs.readdir(path, option, callback)</code></td>
<td>读取文件夹内容（异步）</td>
</tr>
<tr>
<td><code>fs.readdirSync(path, option)</code></td>
<td>读取文件夹内容（同步）</td>
</tr>
<tr>
<td><code>fs.stat(path, callback)</code></td>
<td>查看文件状态（异步）</td>
</tr>
<tr>
<td><code>fs.statSync(path)</code></td>
<td>查看文件状态（同步）</td>
</tr>
</tbody>
</table>
<h1 id="path-">path路径模块</h1>
<h2 id="-">路径操作的问题</h2>
<p>在读写文件的时候，文件路径可以写相对路径或者绝对路径</p>
<pre><code class="lang-javascript">//data.txt是相对路径，读取当前目录下的data.txt, 相对路径相对的是指向node命令的路径
//如果node命令不是在当前目录下执行就会报错， 在当前执行node命令的目录下查找data.txt，找不到
fs.readFile(&quot;data.txt&quot;, &quot;utf8&quot;, function(err, data) {
  if(err) {
    console.log(&quot;读取文件失败&quot;, err);
  }

  console.log(data);
});
</code></pre>
<p>相对路径：相对于执行node命令的路径</p>
<p>绝对路径：<code>__dirname</code>: 当前文件的目录，<code>__filename</code>: 当前文件的目录，包含文件名</p>
<h2 id="path-">path模块的常用方法</h2>
<blockquote>
<p>关于路径，在linux系统中，路径分隔符使用的是<code>/</code>，但是在windows系统中，路径使用的<code>\</code></p>
</blockquote>
<p>在我们拼写路径的时候会带来很多的麻烦，经常会出现windows下写的代码，在linux操作系统下执行不了，path模块就是为了解决这个问题而存在的。</p>
<p>常用方法：</p>
<pre><code class="lang-javascript">path.join();//拼接路径

//windows系统下
&gt; path.join(&quot;abc&quot;,&quot;def&quot;,&quot;gg&quot;, &quot;index.html&quot;)
&quot;abc\def\gg\a.html&quot;

//linux系统下
&gt; path.join(&quot;abc&quot;,&quot;def&quot;,&quot;gg&quot;, &quot;index.html&quot;)
&#39;abc/def/gg/index.html&#39;

path.basename(path[, ext])    返回文件的名称
path.dirname(path)    返回路径的目录名
path.extname(path)    获取路径的扩展名

var path = require(&quot;path&quot;);
var temp = &quot;abc\\def\\gg\\a.html&quot;;
console.log(path.basename(temp));//a.html
console.log(path.dirname(temp));//abc\def\gg
console.log(path.extname(temp));//.html
</code></pre>
<p>【优化读写文件的代码】</p>
<h2 id="path-api-">path模块其他api（了解）</h2>
<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>path.basename(path[, ext])</code></td>
<td>返回文件的最后一部分</td>
</tr>
<tr>
<td><code>path.dirname(path)</code></td>
<td>返回路径的目录名</td>
</tr>
<tr>
<td><code>path.extname(path)</code></td>
<td>获取路径的扩展名</td>
</tr>
<tr>
<td><code>path.isAbsolute(path)</code></td>
<td>判断目录是否是绝对路径</td>
</tr>
<tr>
<td><code>path.join([...paths])</code></td>
<td>将所有的path片段拼接成一个规范的路径</td>
</tr>
<tr>
<td><code>path.normalize(path)</code></td>
<td>规范化路径</td>
</tr>
<tr>
<td><code>path.parse(path)</code></td>
<td>将一个路径解析成一个path对象</td>
</tr>
<tr>
<td><code>path.format(pathObj)</code></td>
<td>讲一个path对象解析成一个规范的路径</td>
</tr>
</tbody>
</table>
<h1 id="http-">http模块</h1>
<h2 id="-">创建服务器基本步骤</h2>
<pre><code class="lang-javascript">//1. 导入http模块，http模块是node的核心模块，作用是用来创建http服务器的。
var http = require(&quot;http&quot;);

//2. 创建服务器
var server = http.createServer();

 //3. 启动服务器，监听某个端口
server.listen(9999, function(){
  console.log(&quot;服务器启动成功了, 请访问： http://localhost:9999&quot;);
});

//4.服务器处理请求
server.on(&quot;request&quot;, function(req,res) {
    //只要给请求一律给OK
    res.end(&quot;OK&quot;)
  console.log(&quot;我接收到请求了&quot;);
});
</code></pre>
<p>详细说明</p>
<ol>
<li>给服务器注册request事件，只要服务器接收到了客户端的请求，就会触发request事件</li>
<li>request事件有两个参数，request表示请求对象，可以获取所有与请求相关的信息，response是响应对象，可以获取所有与响应相关的信息。</li>
<li>服务器监听的端口范围为：1-65535之间，推荐使用3000以上的端口，因为3000以下的端口一般留给系统使用(6666端口号不可用)</li>
</ol>
<p><strong>创建服务器简写形式</strong></p>
<pre><code class="lang-js">const http = require(&quot;http&quot;)
http.creatServer((req,res)=&gt;{
    res.end(&quot;OK&quot;)
}).listen(8888,()=&gt;{
    console.log(&quot;服务器启动成功了&quot;)
})
</code></pre>
<h2 id="request-req-">request请求对象详解(req)</h2>
<p>文档地址：<a href="http://nodejs.cn/api/http.html#http_message_headers">http://nodejs.cn/api/http.html#http_message_headers</a></p>
<p>常见属性：</p>
<pre><code class="lang-javascript">headers: 所有的请求头信息
method： 请求的方式
url： 请求的地址
</code></pre>
<p>注意：在发送请求的时候，可能会出现两次请求的情况，这是因为谷歌浏览器会自动增加一个<code>favicon.ico</code>的请求。</p>
<p>小结：request对象中，常用的就是method和url两个参数</p>
<h2 id="response-res-">response响应对象详解(res)</h2>
<p>文档地址：<a href="http://nodejs.cn/api/http.html#http_class_http_serverresponse">http://nodejs.cn/api/http.html#http_class_http_serverresponse</a></p>
<p>常见的属性和方法：</p>
<pre><code class="lang-javascript">res.write(data): 设置响应体片段（给浏览器发送请求体，可以调用多次，从而提供连续的请求体
res.end(); 响应结束只能调用一次（通知服务器，所有响应头和响应主体都已被发送，即服务器将其视为已完成。
res.end(data); 结束请求，并且响应一段内容，相当于res.write(data) + res.end()
res.statusCode: 响应的的状态码 200成功 302重定向 304缓存 404找不到 5xx服务器报错
res.statusMessage: 响应的状态信息， OK Not Found ,会根据statusCode自动设置。
res.setHeader(name, value); 设置响应头信息， 比如res.setHeader(&#39;content-type&#39;,&#39;text/html; chartset=utf-8&#39;)
res.writeHead(statusCode, statusMessage, options); 设置响应头，同时可以设置状态码和状态信息。
</code></pre>
<p><strong>注意：必须先设置响应头，才能设置响应。</strong> </p>
<h1 id="-web-">实现静态WEB服务器</h1>
<h2 id="-">服务器响应首页</h2>
<ul>
<li>注意：浏览器中输入的URL地址，仅仅是一个标识，不与服务器中的目录一致。也就是说：返回什么内容是由服务端的逻辑决定</li>
</ul>
<pre><code class="lang-js">server.on(&#39;request&#39;, function(req, res) {
  var url = req.url
  if(url === &#39;/&#39;) {
    fs.readFile(&#39;./index.html&#39;, function(err, data) {
      if(err) {
        return res.end(&#39;您访问的资源不存在~&#39;)
      }

      res.end(data)
    })
  }
})
</code></pre>
<h2 id="-url-">根据根据不同url，响应不同文件</h2>
<h2 id="content-type-mime-">content-type设置-MIME类型</h2>
<ul>
<li>MIME(Multipurpose Internet Mail Extensions)多用途Internet邮件扩展类型 是一种表示文档性质和格式的标准化方式</li>
<li>浏览器通常使用MIME类型（而不是文件扩展名）来确定如何处理文档；因此服务器将正确的MIME类型附加到响应对象的头部是非常重要的</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_Types">MIME 类型</a></li>
</ul>
<h2 id="-">静态资源的通用处理</h2>
<h2 id="mime-mime-">MIME类型的通用处理-mime模块</h2>
<ul>
<li>作用：获取文件的MIME类型</li>
<li>安装：<code>npm i mime</code></li>
</ul>
<pre><code class="lang-js">var mime = require(&#39;mime&#39;)

// 自动根据文件名/文件路径 获取对应的MIME类型
mime.getType(url)                    // ⇨ &#39;text/plain&#39;
// 根据MIME获取到文件后缀名
mime.getExtension(&#39;text/plain&#39;)        // ⇨ url
</code></pre>
<h1 id="npm-node-">npm - Node包管理工具</h1>
<h2 id="npm-">npm的基本概念</h2>
<ul>
<li>node package manager</li>
<li><a href="https://npmjs.com">npm官网</a></li>
<li><a href="https://www.npmjs.com.cn/">npm中文文档</a></li>
</ul>
<pre><code class="lang-html">1. npm 是node的包管理工具，
2. 它是世界上最大的软件注册表，每星期大约有 30 亿次的下载量，包含超过 600000 个 包（package） （即，代码模块）。
3. 来自各大洲的开源软件开发者使用 npm 互相分享和借鉴。包的结构使您能够轻松跟踪依赖项和版本。
</code></pre>
<ul>
<li>作用：通过<code>npm</code>来快速安装开发中使用的包</li>
<li>npm不需要安装，只要安装了node，就自带了<code>npm</code></li>
</ul>
<h2 id="npm-">npm基本使用</h2>
<h3 id="-">初始化包</h3>
<pre><code class="lang-javascript">npm init;    //这个命令用于初始化一个包，创建一个package.json文件，我们的项目都应该先执行npm init
npm init -y;  //快速的初始化一个包， 不能是一个中文名
</code></pre>
<h3 id="-">安装包</h3>
<pre><code class="lang-javascript">npm install 包名;  //安装指定的包名的最新版本到项目中
npm install 包名@版本号;  //安装指定包的指定版本
//jQuery@1.12

npm i 包名； //简写
</code></pre>
<p>注意：如果修改使用依赖包的版本，规范：先卸载旧版，再安装新版本 </p>
<p>如果只有package.json文件，没有node_modules文件夹</p>
<p>可以使用 <strong>npm i 默认安装整个依赖</strong></p>
<h3 id="-">卸载包</h3>
<pre><code class="lang-javascript">npm uninstall 包名;  //卸载已经安装的包
</code></pre>
<h3 id="-">清除缓存</h3>
<pre><code class="lang-javascript">npm cache clean -f // 如果npm安装失败了，可以用这个命令来清除缓存
</code></pre>
<h2 id="package-json-">package.json文件</h2>
<p>package.json文件，包（项目）描述文件，用来管理组织一个包（项目），它是一个纯JSON格式的。</p>
<ul>
<li>作用：描述当前项目（包）的信息，描述当前包（项目）的依赖项</li>
<li>如何生成：<code>npm init</code>或者<code>npm init -y</code></li>
<li>作用<ul>
<li>作为一个标准的包，必须要有<code>package.json</code>文件进行描述</li>
<li>一个项目的node_modules目录通常都会很大，不用拷贝node_modules目录，可以通过package.json文件配合<code>npm install</code>直接安装项目所有的依赖项</li>
</ul>
</li>
<li>描述内容</li>
</ul>
<pre><code class="lang-json">{
  &quot;name&quot;: &quot;03-npm&quot;,  //描述了包的名字，不能有中文
  &quot;version&quot;: &quot;1.0.0&quot;,  //描述了包的的版本信息， x.y.z  如果只是修复bug，需要更新Z位。如果是新增了功能，但是向下兼容，需要更新Y位。如果有大变动，向下不兼容，需要更新X位。
  &quot;description&quot;: &quot;&quot;, //包的描述信息
  &quot;main&quot;: &quot;index.js&quot;, //入口文件（模块化加载规则的时候详细的讲）
  &quot;scripts&quot;: {  //配置一些脚本，在vue的时候会用到，现在体会不到
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;
  },
  &quot;keywords&quot;: [],  //关键字（方便搜索）
  &quot;author&quot;: &quot;&quot;,  //作者的信息
  &quot;license&quot;: &quot;ISC&quot;,  //许可证，开源协议
  &quot;dependencies&quot;: {   //重要，项目的依赖， 方便代码的共享  通过 npm install可以直接安装所有的依赖项
    &quot;bootstrap&quot;: &quot;^3.3.7&quot;,
    &quot;jquery&quot;: &quot;^3.3.1&quot;
  }
}
</code></pre>
<p><strong>注意：一个合法的package.json，必须要有name和version两个属性</strong> </p>
<h2 id="-">本地安装和全局安装</h2>
<p>有两种方式用来安装 npm 包：本地安装和全局安装。选用哪种方式来安装，取决于你如何使用这个包。 </p>
<ul>
<li>全局安装：如果你想将其作为一个命令行工具，那么你应该将其安装到全局。这种安装方式后可以让你在任何目录下使用这个命令。比如less命令，webpack命令，hcc-md命令 。</li>
<li>本地安装：如果你自己的模块依赖于某个包，并通过 Node.js 的 <code>require</code> 加载，那么你应该选择本地安装，这种方式也是 <code>npm install</code> 命令的默认行为。</li>
</ul>
<pre><code class="lang-javascript">// 全局安装,会把npm包安装到C:\Users\HUCC\AppData\Roaming\npm目录下，作为命令行工具使用
npm install -g 包名;

//全局卸载 
npm uninstall -g 包名;

//本地安装，会把npm包安装到当前项目的node_modules文件中，作为项目的依赖
npm install 包名;  
</code></pre>
<h2 id="-">更新全局安装的包</h2>
<pre><code class="lang-bash">#    更新全局指定的包,jshint是包名
npm update -g jshint
#    要找出需要更新的软件包
npm outdated -g --depth=0.
#    要更新所有全局软件包
npm update -g.
</code></pre>
<h2 id="-">常见的命令行工具</h2>
<h3 id="nrm-">nrm(淘宝镜像)</h3>
<ul>
<li>nrm：npm registry manager（npm仓库地址管理工具）</li>
<li>安装：<code>npm i -g nrm</code></li>
</ul>
<pre><code class="lang-shell"># 带*表示当前正在使用的地址

# 查看仓库地址列表
nrm ls
# 切换仓库地址
nrm use taobao
</code></pre>
<pre><code class="lang-bash">npm i -g cnpm --registry=https://registry.npm.taobao.org
</code></pre>
<h3 id="nodemon-">nodemon 自动重启</h3>
<ul>
<li>作用：监视到js文件修改后，自动重启node程序</li>
<li>安装：<code>npm i -g nodemon</code></li>
<li>使用：<code>nodemon app.js</code> 运行node程序</li>
</ul>
<h1 id="-web-">实现动态WEB服务器</h1>
<h2 id="-node-art-template">在node中使用art-template</h2>
<ul>
<li><a href="https://aui.github.io/art-template/zh-cn/docs/">文档</a></li>
<li>安装</li>
</ul>
<pre><code class="lang-bash">npm install art-template
</code></pre>
<ul>
<li>核心方法</li>
</ul>
<pre><code class="lang-javascript">// 基于模板路径渲染模板
//参数1：文件的决定路径
//参数2：数据
//返回值：返回渲染后的内容
// template(filename, data)
let html = template(path.join(__dirname, &quot;pages&quot;, &quot;index.html&quot;), {name:&quot;大吉大利，今晚吃鸡&quot;});
</code></pre>
<p><strong>注意点：文件的路径必须是绝对路径</strong></p>
<h2 id="get-url-">get请求处理-url模块</h2>
<ul>
<li>说明：用于 URL 处理与解析</li>
<li>注意：通过url拿到的查询参数都是字符串格式</li>
</ul>
<pre><code class="lang-js">// 导入url模块
var url = require(&#39;url&#39;)

// 解析 URL 字符串并返回一个 URL 对象
// 第一个参数：表示要解析的URL字符串
// 第二个参数：是否将query属性（查询参数）解析为一个对象，如果为：true，则query是一个对象
var ret = url.parse(&#39;http://localhost:3000/details?id=1&amp;name=jack&#39;, true)
console.log(ret.query) // { id: &#39;1&#39;, name: &#39;jack&#39; }
</code></pre>
<h2 id="-">服务端重定向</h2>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status">HTTP 状态码说明</a></li>
<li><a href="http://shuai.be/archives/301-302-redirection/">301 和 302</a></li>
<li>说明：服务端可以通过HTTP状态码让浏览器中的页面重定向</li>
</ul>
<pre><code class="lang-js">//常规版
res.setHeader(&quot;location&quot;,&quot;/&quot;)
res.statusCode = 302
res.end()

//简化版
res.writeHead(302, {
  &#39;Location&#39;: &#39;/&#39;
})
res.end()
</code></pre>
<h2 id="moment-">moment日期格式化插件</h2>
<p>moment日期格式化插件，可以在普通js中使用,用法参考官网</p>
<pre><code class="lang-js">moment().format();//国标
</code></pre>
<h2 id="post-">POST请求参数的处理</h2>
<ul>
<li>说明：POST请求可以发送大量数据，没有大小限制</li>
</ul>
<pre><code class="lang-js">// 接受POST参数
var postData = []
// data事件：用来接受客户端发送过来的POST请求数据
var result = &quot;&quot;;
req.on(&#39;data&#39;, function (chunk) {
  result += chunk;
})

// end事件：当POST数据接收完毕时，触发
req.on(&#39;end&#39;, function () {
  cosnole.log(result); 
})

</code></pre>
<h2 id="-querystring-">请求体处理-querystring模块</h2>
<ul>
<li>用于解析与格式化 URL 查询字符串</li>
<li>注意：只在专门处理查询字符串时使用</li>
</ul>
<pre><code class="lang-js">// foo=bar&amp;abc=xyz&amp;abc=123
var querystring = require(&#39;querystring&#39;)

// 将查询参数转化为对象
// 第一个参数: 要解析的 URL 查询字符串
querystring.parse(&#39;foo=bar&amp;abc=xyz&#39;) // { foo: &#39;bar&#39;, abc: &#39;xyz&#39; }
</code></pre>
<h1 id="-">模块化</h1>
<h2 id="-">基本概念</h2>
<blockquote>
<p>在nodejs中，应用由模块组成，nodejs中采用commonJS模块规范。</p>
</blockquote>
<ol>
<li>一个js文件就是一个模块</li>
<li><p>每个模块都是一个独立的作用域，在这个而文件中定义的变量、函数、对象都是私有的，对其他文件不可见。</p>
</li>
<li><p><code>01-模块化的概念</code>用于演示每一个模块都有自己单独的作用域</p>
</li>
</ol>
<h2 id="node-">node中模块分类</h2>
<ul>
<li>1 核心模块<ul>
<li>由 node 本身提供，不需要单独安装（npm），可直接引入使用</li>
</ul>
</li>
<li>2 第三方模块<ul>
<li>由社区或个人提供，需要通过npm安装后使用</li>
</ul>
</li>
<li>3 自定义模块<ul>
<li>由我们自己创建，比如：tool.js 、 user.js</li>
</ul>
</li>
</ul>
<h3 id="-">核心模块</h3>
<ul>
<li>fs：文件操作模块</li>
<li>http：网络操作模块</li>
<li>path：路径操作模块</li>
<li>url: 解析地址的模块</li>
<li>querystring: 解析参数字符串的模块</li>
<li>基本使用：1 先引入  2 再使用</li>
</ul>
<pre><code class="lang-js">// 引入模块
var fs = require(&#39;fs&#39;);
</code></pre>
<h3 id="-">第三方模块</h3>
<ul>
<li>第三方模块是由 社区或个人 提供的</li>
<li>比如：mime模块/art-template/jquery...</li>
<li>基本使用：1 先通过npm下载 2 再引入 3 最后使用</li>
</ul>
<h3 id="-">用户自定义模块</h3>
<ul>
<li>由开发人员创建的模块（JS文件）</li>
<li>基本使用：1 创建模块 2 引入模块</li>
<li>注意：自定义模块的路径必须以<code>./</code>获取<code>../</code>开头</li>
</ul>
<pre><code class="lang-js">// 加载模块
require(&#39;./a&#39;)     // 推荐使用，省略.js后缀！

require(&#39;./a.js&#39;)
</code></pre>
<h2 id="-">模块的导入与导出</h2>
<h3 id="-">模块导入</h3>
<ul>
<li>通过<code>require(&quot;fs&quot;)</code>来加载模块</li>
<li>如果是第三方模块，需要先使用npm进行下载</li>
<li>如果是自定义模块，需要加上相对路径<code>./</code>或者<code>../</code>,可以省略<code>.js</code>后缀，如果文件名是<code>index.js</code>那么index.js也可以省略。</li>
<li>模块可以被多次加载，但是只会在第一次加载</li>
</ul>
<h3 id="-">模块导出</h3>
<ul>
<li>在模块的内部，<code>module</code>变量代表的就是当前模块，它的<code>exports</code>属性就是对外的接口，加载某个模块，加载的就是<code>module.exports</code>属性，这个属性指向一个空的对象。</li>
</ul>
<pre><code class="lang-javascript">//module.exports指向的是一个对象，我们给对象增加属性即可。
//module.exports.num = 123;
//module.exports.age = 18;

//通过module.exports也可以导出一个值，但是多次导出会覆盖
module.exports = &#39;123&#39;;
module.exports = &quot;abc&quot;;
</code></pre>
<h3 id="module-exports-exports">module.exports与exports</h3>
<ol>
<li>一个模块的导出，就看module.exports的值</li>
<li><p>默认exports和module.exports<strong>指向</strong>了同一个对象</p>
</li>
<li><p><code>exports</code> 是 <code>module.exports</code> 的引用</p>
</li>
<li>注意：给 <code>module.exports</code> 赋值会切断与 <code>exports</code> 之间的联系<ul>
<li>1 直接添加属性两者皆可</li>
<li>2 赋值操作时，只能使用 <code>module.exports</code>，复杂数据类型都是存地址，地址修改后对象就变了</li>
</ul>
</li>
</ol>
<pre><code class="lang-js">console.log( module.exports === exports ) // ==&gt; true

// 等价操作
module.exports.num = 123
exports.num = 123

// 赋值操作：不要使用 exports = {}
module.exports = {}
</code></pre>
<h3 id="-mime-">第三方模块（以mime包为例）</h3>
<ul>
<li>先基于当前文件模块所属目录找 node_modules 目录</li>
<li>如果找到，则去该目录中找 mime 目录</li>
<li>如果找到 mime 目录，则找该目录中的 package.json 文件</li>
<li>如果找到 package.json 文件，则找该文件中的 main 属性</li>
<li>如果找到 main 属性，则拿到该属性对应的文件路径</li>
<li>如果找到 mime 目录之后<ul>
<li>发现没有 package.json</li>
<li>或者 有 package.json 没有 main 属性</li>
<li>或者 有 main 属性，但是指向的路径不存在</li>
<li>则 node 会默认去看一下 mime 目录中有没有 index.js index.node index.json 文件</li>
</ul>
</li>
<li>如果找不到 index 或者找不到 mime 或者找不到 node_modules</li>
<li>则进入上一级目录找 node_moudles 查找规则同上</li>
<li>如果上一级还找不到，继续向上，一直到当前文件所属磁盘根目录</li>
<li>如果最后到磁盘根目录还找不到，最后报错：<code>can not find module xxx</code></li>
</ul>
<h1 id="express">Express</h1>
<h2 id="express-">Express 框架</h2>
<ul>
<li><strong>基于 Node.js 平台，快速、开放、极简的 web 开发框架</strong></li>
<li><a href="http://expressjs.com/">express 官网</a></li>
<li><a href="http://expressjs.com.cn/">express 中文网</a></li>
</ul>
<h3 id="-">起步</h3>
<ul>
<li>安装：<code>npm i express</code></li>
</ul>
<pre><code class="lang-js">// 导入 express
var express = require(&#39;express&#39;)
// 创建 express实例，也就是创建 express服务器
var app = express()

// 路由
app.get(&#39;/&#39;, function (req, res) {
  res.send(&#39;Hello World!&#39;)
})

// 启动服务器
app.listen(3000, function () {
  console.log(&#39;服务器已启动&#39;)
})
</code></pre>
<h3 id="api-">API说明</h3>
<ul>
<li><code>express()</code>：创建一个Express应用，并返回，即：app</li>
<li><code>app.get()</code>：注册一个GET类型的路由<ul>
<li>注意：只要注册了路由，所有的请求都会被处理（未配置的请求路径，响应404）</li>
</ul>
</li>
<li><code>res.send()</code>：发送数据给客户端，并自动设置Content-Type</li>
<li><code>res.sendFile()</code>：发送文件给客户端，并自动设置Content-Type<ul>
<li>参数可以是：字符串、数组、对象、Buffer</li>
<li>注意：只能使用一次</li>
</ul>
</li>
<li><code>req</code> 和 <code>res</code>：与http模块中的作用相同，是扩展后的请求和响应对象</li>
</ul>
<h2 id="-">注册路由</h2>
<ul>
<li>1 <code>app.METHOD</code>：比如：app.get / app.post / app.delete / app.patch</li>
<li>3 <code>app.use(path, callback)</code> 更重要的作用是处理中间件<ul>
<li>注意：只要是以path开头的请求地址，都可以被use处理</li>
<li>注意：可以处理任意的请求类型</li>
<li>注意：path参数可省略，默认值为：<code>/</code></li>
</ul>
</li>
</ul>
<h2 id="express-">express中间件</h2>
<blockquote>
<p>中间件：中间处理的部件，这个部件处理完成后，会交给下一个部件处理</p>
</blockquote>
<ol>
<li>express中间件是一个函数 (req,res) =&gt;{......}</li>
<li>中间件可以获取上一个中间件的内容，req res</li>
<li>中间件，可以对内容进行进一步处理，可以对req和res进行处理</li>
<li>处理完成后，可以给下一次匹配中间件去使用</li>
</ol>
<pre><code class="lang-js">//不写&quot;/&quot;,也是匹配所有
app.get(&quot;/&quot;,(req,res,next)=&gt;{
    //第三参数：将处理过的req和res交给下一个匹配的中间件处理
    next()
    //next()调用将请求交给下一个中间件的使用
    req.id //获取请求电脑的ip地址
})
app.get(&quot;/&quot;,(req,res)=&gt;{
    //匹配的中间件
})
</code></pre>
<h3 id="-post-">利用中间件处理post请求参数原理</h3>
<pre><code class="lang-js">//不写&quot;/&quot;,也是匹配所有
app.use(&quot;/&quot;,(req,res，next)=&gt;{
    const results = &quot;&quot;
    req.on(&quot;data&quot;,chunk=&gt;{
        results += chunk
    })

    req.on(&quot;end&quot;,()=&gt;{
        //将post数据处理成键值对形式
        const query = querystring.parse(results)
        //将数据处理后存储到请求体中
        req.body = query
        next()
    })
})
</code></pre>
<h2 id="-">实现静态服务器</h2>
<ul>
<li><code>req.path</code>：请求路径<ul>
<li>示例：URL为&#39;example.com/users?sort=desc&#39;，path表示：<code>/users</code></li>
</ul>
</li>
<li><code>res.sendFile()</code></li>
</ul>
<h3 id="-">处理静态资源</h3>
<ul>
<li>静态资源：图片、CSS、JavaScript 文件 等</li>
<li>如何处理？使用 express.static() 方法来托管静态资源</li>
<li>注意：<code>express.static()</code>可以调用多次</li>
<li>思考：<code>app.use(&#39;/web&#39;, express.static(&#39;web&#39;))</code> 的含义？<ul>
<li>访问：<code>http://localhost:3000/web/anoceanofsky.jpg</code></li>
</ul>
</li>
</ul>
<pre><code class="lang-js">// 托管web目录下的静态资源
app.use(express.static(&#39;web&#39;))
// 相当于：app.use(&#39;/&#39;, express.static(&#39;web&#39;))
app.use(&#39;/&#39;, express.static(path.join(__driname,&quot;web&quot;)))
// 访问上述静态资源
// http://localhost:3000/anoceanofsky.jpg

// 当请求达到服务器后，express就会到web目录下，查找anoceanofsky.jpg
// 并读取该文件，返回给浏览器
</code></pre>
<h2 id="express-req-">express对于req新增内容</h2>
<h3 id="request-">request常用属性和方法</h3>
<pre><code class="lang-js">// 获取请求路基中的参数，是一个对象 ---&gt; Get请求参数
req.query

// 获取POST请求参数，需要配置`body-parser`模块， POST请求参数
req.body
</code></pre>
<ul>
<li>获取<code>POST</code>请求参数（配置<code>body-parser</code>模块）</li>
</ul>
<pre><code class="lang-js">//安装下载中间件 body-parser 和 multer
//Multer 是一个 node.js 中间件，用于处理 multipart/form-data 类型的表单数据，它主要用于上传文件。它是写在 busboy 之上非常高效。

// 将POST请求参数转化为对象，存储到req.body中

// 导入body-parser模块
var bodyParser = require(&#39;body-parser&#39;);

//以下两条是配置中间件的
app.use(bodyParser.json());// for parsing application/json
app.use(bodyParser.urlencoded({ extended: true })); // for parsing application/x-www-form-urlencoded

// 此时，就可以获取到POST请求参数了
console.log(req.body)
</code></pre>
<h2 id="express-res-">express对于res新增内容</h2>
<h3 id="response-">response常用属性和方法</h3>
<pre><code class="lang-js">// send() 发送数据给客户端，并自动设置Content-Type
res.send()

// 发送文件给浏览器，并根据文件后缀名自动设置Content-Type
// 注意：文件路径必须是绝对路径
res.sendFile(path.join(__dirname, &#39;index.html&#39;))

// 设置HTTP响应码
res.sendStatus(200) // equivalent to res.status(200).send(&#39;OK&#39;)
res.sendStatus(404)
res.send(&quot;404 not found&quot;)//equivalent to res.sendStatus(404).send(&quot;404 not found&quot;)

// 设置响应头
res.set(&#39;Content-Type&#39;, &#39;text/plain&#39;)
res.set({
  &#39;Content-Type&#39;: &#39;text/plain&#39;,
  &#39;cute&#39;: &#39;fangfang&#39;
})

// 重定向
res.redirect(&#39;/index&#39;)

</code></pre>
<h2 id="express-">Express使用模板引擎</h2>
<pre><code class="lang-js">// 为后缀为html的模板设置模板引擎
app.engine(&#39;html&#39;, require(&#39;express-art-template&#39;))

// 设置模板文件所在的目录(使用相对路径需要设置)
app.set(&#39;views&#39;, &#39;./&#39;)
// 设置模板文件的后缀为 html
app.set(&#39;view engine&#39;, &#39;html&#39;)

// 渲染 index.html 模板文件，并发送给浏览器
res.render(&#39;index&#39;, { list: [] })

</code></pre>
<h2 id="express-">Express 中外置路由使用</h2>
<ul>
<li>目的：将路由封装到一个独立的路由模块中，有利于代码的封装和模块化</li>
</ul>
<pre><code class="lang-js">/*
  router.js 文件代码如下:
*/

// 1 加载 express 模块
var express = require(&#39;express&#39;)

// 2 调用 express.Router() 方法，得到一个路由容器实例
var router = express.Router()

// 3 为 router 添加不同的路由
router.get(&#39;/&#39;, function (req, res) {
  res.send(&#39;hello express&#39;)
})
router.get(&#39;/add&#39;, function (req, res) {

})

// 4. 将 router 路由容器导出
module.exports = router

</code></pre>
<pre><code class="lang-js">/*
  在 app.js 文件中：
*/
var express = require(&#39;express&#39;)

// 1 加载上面自定义的路由模块
var router = require(&#39;./router&#39;)

var app = express()

// 2. 将自定义路由模块 router 通过 app.use() 方法挂载到 app 实例上
//    这样 app 实例程序就拥有了 router 的路由
app.use( router )

app.listen(3000, function () {
  console.log(&#39;running...&#39;)
})

</code></pre>
<h1 id="-">数据库基本概念</h1>
<h2 id="-">为什么要有数据库</h2>
<p>没有数据库，我们的数据都是存储在文件当中的，那么文件存储数据的缺点有：</p>
<ul>
<li>文件的安全性问题。</li>
<li>文件不利于查询和对数据的管理。</li>
<li>文件不利于存放海量数据</li>
<li>文件在程序中控制不方便</li>
</ul>
<h2 id="-">什么是数据库</h2>
<p>数据库，简而言之可视为电子化的文件柜——存储电子文件的处所，用户可以对文件中的数据运行增加、删除、修改、查询等操作。</p>
<p>前端程序员只需要对数据库有一定了解即可。</p>
<p><strong>浏览器----&gt;服务器----&gt;数据库</strong></p>
<h2 id="-">数据库的分类</h2>
<p>关系型数据库：</p>
<ul>
<li><strong>MySQL</strong>、</li>
<li>Oracle、</li>
<li>SQL Server</li>
<li>SQLite（安卓）</li>
</ul>
<p>非关系型数据库</p>
<ul>
<li>mongodb</li>
<li>redis</li>
<li>BigTable</li>
</ul>
<p>DBA</p>
<h2 id="-">数据库中基本术语</h2>
<ul>
<li>数据库<code>database</code>：存放数据的仓库，一般一个项目中的数据会存储到一个数据库中</li>
<li>表<code>table</code>： 一个表对应一类数据，比如学生表，老师表</li>
<li>列<code>columns</code>:一张表由多列组成，也叫一个字段，比如学生的姓名，成绩，年龄等</li>
<li>行<code>rows</code>: 一个学生信息对应一行，一行也叫一条记录。</li>
</ul>
<h1 id="-">数据库的可视化操作</h1>
<h2 id="-">创建数据库</h2>
<h2 id="-">创建表</h2>
<pre><code>存储以下学生信息

{id: 1, name: &#39;张三&#39;, age: 18, gender: &#39;男&#39;, content: &#39;这是描述信息‘}
</code></pre><h2 id="-">数据类型</h2>
<p><code>int</code>: 整数类型</p>
<p><code>varchar</code>: 字符类型</p>
<p><code>datetime</code>: 日期类型</p>
<h1 id="-">数据库的常见命令</h1>
<blockquote>
<p>SQL: 结构化查询语言(Structured Query Language)简称 SQL 。用于数据库的增删改查以及管理等功能。</p>
</blockquote>
<h2 id="-">数据库相关</h2>
<ul>
<li><code>--</code>SQL 中的注释</li>
<li><code>SHOW DATABASES;</code> 查看所有的数据</li>
<li><code>CREATE DATABASE mydb;</code> 创建数据库</li>
<li><code>DROP DATABASE mydb;</code>删除数据库</li>
<li><code>USE mydb;</code> 使用数据库</li>
</ul>
<h2 id="-">表相关</h2>
<ul>
<li><code>SHOW TABLES;</code>查看当前数据库中所有的表</li>
<li>创建表</li>
</ul>
<pre><code class="lang-sql">CREATE TABLE user(
    id INT auto_increment PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    age INT ,
    gender VARCHAR(4),
    content VARCHAR(255)
    createtime timestamp not null default current_timestamp,--设置默认自动生成时间
    updatetime timestamp default current_timestamp on update current_timestamp --设置自动更改时间
)

--TIMESTAMP和DATETIME的不同点：对于TIMESTAMP，它把客户端插入的时间从当前时区转化为UTC（世界标准时间）进行存储。查询时，将其又转化为客户端当前时区进行返回。而对于DATETIME，不做任何改变，基本上是原样输入和输出。


</code></pre>
<ul>
<li><code>DROP TABLE user;</code>删除表</li>
</ul>
<h2 id="-">插入数据</h2>
<pre><code class="lang-sql">--字段名(列名)，键与值需要一一对应
INSERT INTO user (name, age, gender, content) VALUES (&#39;鹏鹏&#39;, 18, &#39;男&#39;, &#39;哈哈哈，哈哈哈&#39;)

-- 如果省略列名，那么必须要和所有字段(列名)一一对应，没有值填写NUll占位置
INSERT INTO user VALUES (null, &#39;鹏鹏&#39;, 18, &#39;男&#39;, &#39;哈哈哈，哈哈哈&#39;)

--可以只填写必填项
INSERT INTO user SET name=&#39;pp&#39;, age=18, gender=&#39;男&#39;, content=&#39;嘻嘻嘻&#39;
</code></pre>
<h2 id="-">修改数据</h2>
<pre><code class="lang-sql">// 修改所有的数据
UPDATE USER SET name=&#39;大鹏子&#39;
// 根据条件修改
UPDATE USER set name=&#39;鹏鹏&#39;, content=&quot;这是内容&quot; WHERE id = 2
</code></pre>
<h2 id="-">删除数据</h2>
<pre><code class="lang-sql">// 删除所有的数据
DELETE FROM USER

// 删除id为5的数据
DELETE FROM USER WHERE id = 5
</code></pre>
<h2 id="-">查询数据</h2>
<pre><code class="lang-sql">-- 查询所有数据
SELECT * FROM user

-- 查询指定列
SELECT id, name,age from user

</code></pre>
<h2 id="-">条件查询</h2>
<pre><code class="lang-sql">--- 并且
SELECT * from user where name=&#39;鹏鹏&#39; AND age=21

--- 或者
SELECT * from user where name=&#39;鹏鹏&#39; or age=21

-- 范围查询

-- 模糊查询  %表示通配  _表示单个字符
SELECT * from user where name LIKE &#39;%鹏&#39; --后面含有鹏
SELECT * from user where name LIKE &#39;鹏%&#39; --前面含有鹏
SELECT * from user where name LIKE &#39;%鹏%&#39; --包含

-- in语句
SELECT * from user where name in (&#39;鹏鹏&#39;, &#39;pp&#39;)

-- order by
-- 排序需要写在最后面，，默认asc升序  desc：降序
SELECT * from user ORDER BY id desc

-- limit分页，limit 参数：一跳过几条，参数二：选取几条
--只写一个参数默认为第二个参数
SELECT * from user ORDER BY id desc limit 3
--跳过三条取三条
SELECT * from user ORDER BY id desc limit 3,3
--案例，每页三条，共两页
--第一页
SELECT * from user ORDER BY id desc limit 0,3;
--第二页
SELECT * from user ORDER BY id desc limit 3,6;

-- 获取总条数
SELECT count(*) as total FROM user
</code></pre>
<h2 id="-">导入和导出数据库脚本</h2>
<h1 id="node-mysql">node 操作 mysql</h1>
<h2 id="-">基本使用</h2>
<ul>
<li>安装</li>
</ul>
<pre><code class="lang-bash">npm install mysql
</code></pre>
<ul>
<li>基本使用</li>
</ul>
<pre><code class="lang-js">// 导入第三方包
const mysql = require(&#39;mysql&#39;)
// 创建连接
var connection = mysql.createConnection({
  // 本地
  host: &#39;localhost&#39;,
  //用户名
  user: &#39;root&#39;,
  //密码
  password: &#39;root&#39;,
  // 数据库名称
  database: &#39;mydb&#39;,
  // 端口号
  port: 3306
})

// 连接数据库
connection.connect()

// 执行sql语句
//connection.query(sql语句，参数列表，回调函数)
connection.query(&#39;select * from user where id = 8&#39;, (err, result) =&gt; {
  if (err) return console.log(&#39;查询失败&#39;, err)
  // result返回的是数组， 数组中是一个对象
  console.log(result)
})

// 关闭连接
connection.end()
</code></pre>
<h2 id="-">查询语句</h2>
<pre><code class="lang-js">var name = &#39;鹏鹏&#39;
//connection.query(sql语句，参数列表，回调函数)
// 使用?表示占位，可以防止sql注入
//方式一
connect.query(&#39;select * from user where name=&quot;name&quot;&#39;,(err, result) =&gt; {
  if (err) return console.log(&#39;错误了&#39;, err)
  console.log(result)
})
//方式二,es6的方法
connect.query(`select * from user where name=${name}`,(err, result) =&gt; {
  if (err) return console.log(&#39;错误了&#39;, err)
  console.log(result)
})
//方式三，系统自带的方法
connect.query(`select * from user where name=?`, name, (err, result) =&gt; {
  if (err) return console.log(&#39;错误了&#39;, err)
  console.log(result)
})
</code></pre>
<h2 id="-">插入语句</h2>
<pre><code class="lang-js">connect.query(
  &#39;insert into user (name, age, gender, content) values (?, ?, ?, ?)&#39;,
  [&#39;鹏哥&#39;, 18, &#39;男&#39;, &#39;哈哈哈哈&#39;],
  err =&gt; {
    if (err) return console.log(&#39;错误&#39;, err)
    console.log(&#39;添加成功了&#39;)
  }
)

// 方式2
connect.query(
  &#39;insert into user set ?&#39;,
  {
    name: &#39;鹏鹏123&#39;,
    age: 30,
    gender: &#39;男&#39;,
    content: &#39;哈哈哈&#39;
  },
  (err, result) =&gt; {
    if (err) return console.log(&#39;错误&#39;, err)
    console.log(&#39;添加成功了&#39;, result)
  }
)
</code></pre>
<h2 id="-">修改语句</h2>
<pre><code class="lang-js">connect.query(
  &#39;update user set ? where id = ?&#39;,
  [
    {
      name: &#39;鹏456&#39;,
      age: 30,
      gender: &#39;男&#39;,
      content: &#39;哈哈哈&#39;
    },
    10
  ],
  (err, result) =&gt; {
    if (err) return console.log(&#39;错误&#39;, err)
    console.log(&#39;添加成功了&#39;, result)
  }
)
</code></pre>
<h2 id="-">删除语句</h2>
<pre><code class="lang-js">//删除单条
connect.query(&#39;delete from user where id = ?&#39;, [10], (err, result) =&gt; {
  if (err) return console.log(&#39;失败&#39;, err)
  console.log(result)
})
//删除多条
const ids = [1,2,3]
const str = ids.join(&quot;,&quot;)
connect.query(`delete from user where id in (${str})`, (err, result) =&gt; {
  if (err) return console.log(&#39;失败&#39;, err)
  console.log(result)
})
</code></pre>
<h2 id="db-">db 模块封装</h2>
<pre><code class="lang-js">// 导入mysql
const mysql = require(&#39;mysql&#39;)

// 创建连接对象
const connect = mysql.createConnection({
  host: &#39;localhost&#39;,
  port: 3306,
  user: &#39;root&#39;,
  password: &#39;root&#39;,
  database: &#39;mydb&#39;
})

exports.query = function(sql, params, callback) {
  connect.connect()
  connect.query(sql, params, (err, data) =&gt; {
    callback &amp;&amp; callback(err, data)
  })
  connect.end()
}
</code></pre>
<h1 id="-">后端实现 - 登录拦截</h1>
<p>目标: 将未登录的用户, 拦截到登录页</p>
<h2 id="-">登录功能基本实现(辅助用的)</h2>
<ol>
<li><p>创建用户表</p>
</li>
<li><p>登录请求</p>
<p> <code>findUser(username, password, callback)</code></p>
</li>
</ol>
<h2 id="-">后端实现 - 状态保持 (登录保持)</h2>
<h3 id="http-">http 无状态</h3>
<h3 id="cookie-session-">cookie 和 session 实现状态保持的原理</h3>
<p><img src="images\http结合cookie和session完成登录状态保持.png" alt=""></p>
<pre><code>喝咖啡的例子
咖啡厅有个活动:  喝 5 杯 送 1 杯
问题1: 不可能一次喝 6 杯, 需要累积
问题2: 服务员是无状态的, 不可能记住所有的客户, 每个客户喝了多少杯
</code></pre><h2 id="-express-session-">依赖 express-session库实现状态保持 - 完成登录拦截 (了解)</h2>
<p>特征:</p>
<ol>
<li>自动开启session</li>
<li>自动将 sessionid 存到浏览器</li>
</ol>
<p>req.session</p>
<p>1、安装express-session <code>npm install express-session</code></p>
<p>2、配置express-session</p>
<pre><code class="lang-js">//依赖express组件需要安装
var app = express()
// 配置session, 会在用户第一次请求时, 自动开启session 和 cookie 的空间
// cookie中会自动存储 sessionId
app.use(session({
  secret: &#39;keyboard cat&#39;,  // 额外秘钥, 根据秘钥进行sessionid加密
  resave: false,
  saveUninitialized: true,  // 是否需要在第一次请求时, 自动存储session 和 cookie
  cookie: { secure: true } //https 安全认证，使用http请求可以不需要这个设置
}))
</code></pre>
<p>3、统一处理未登录的用户</p>
<pre><code class="lang-js">// 统一处理未登录的用户, 只要req.session中没有 user 信息, 说明没登陆
// 直接拦截到登录页 (不管请求的是哪一个页面 =&gt; 匹配所有的路径)
app.use((req, res, next) =&gt; {
  // 登录过, 需要放行, 或者如果就访问的是登陆页, 也放行
  if (req.session.user || req.url === &#39;/login&#39;) {
    // 登录过, 放行
    next()
  } else {
    // 没登陆过, 拦截到登录页
    res.redirect(&#39;/login&#39;)
  }
})
</code></pre>
<p>4、对于登陆请求的处理</p>
<pre><code class="lang-js">// 登录请求的处理 (post请求)
router.post(&#39;/login&#39;, (req, res) =&gt; {
  // console.log(req.body)
  const { username, password } = req.body
  // 根据用户名 和 密码, 去数据库查询, 根据结果判断是否跳转首页
  db.findUser(username, password, results =&gt; {
    if (results.length === 0) {
      // 空数组, 登录失败, 拦截回登录页
      res.redirect(&#39;/login&#39;)
    } else {
      // 成功了  results [{}]
      // console.log(results[0])
      // 将整个用户信息都存到 req.session 空间中
      req.session.user = results[0]
      console.log(req.session)
      res.redirect(&#39;/&#39;)
    }
  })
})
</code></pre>
<h2 id="-">退出功能</h2>
<p>req.session.user = null</p>
<pre><code class="lang-js">router.get(&#39;/logout&#39;, (req, res) =&gt; {
  // 清除服务端, req.session中数据
  req.session.user = null
  res.redirect(&#39;/login&#39;)
})
</code></pre>

          	</article>
        </div>
		</div>
  </body>
</html>
<script type="text/javascript" src="toc/js/jquery-1.4.4.min.js"></script>
<script type="text/javascript" src="toc/js/jquery.ztree.all-3.5.min.js"></script>
<script type="text/javascript" src="toc/js/ztree_toc.js"></script>
<script type="text/javascript" src="toc_conf.js"></script>

<SCRIPT type="text/javascript" >
<!--
$(document).ready(function(){
    var css_conf = eval(markdown_panel_style);
    $('#readme').css(css_conf)
    
    var conf = eval(jquery_ztree_toc_opts);
		$('#tree').ztree_toc(conf);
});
//-->
</SCRIPT>