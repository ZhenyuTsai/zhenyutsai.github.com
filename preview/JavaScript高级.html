<html>
  <head>
	  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>JavaScript高级</title>
    <link rel="shortcut icon" href="favicon.ico" />
		<link href="toc/style/github-bf51422f4bb36427d391e4b75a1daa083c2d840e.css" gmedia="all" rel="stylesheet" type="text/css"/>
		<link href="toc/style/github2-d731afd4f624c99a4b19ad69f3083cd6d02b81d5.css" gmedia="all" rel="stylesheet" type="text/css"/>
    <link href="toc/css/zTreeStyle/zTreeStyle.css" gmedia="all" rel="stylesheet" type="text/css"/>
  <script src="../js/review.js"></script>
    
	  <style>
		pre {
		    counter-reset: line-numbering;
		    border: solid 1px #d9d9d9;
		    border-radius: 0;
		    background: #fff;
		    padding: 0;
		    line-height: 23px;
		    margin-bottom: 30px;
		    white-space: pre;
		    overflow-x: auto;
		    word-break: inherit;
		    word-wrap: inherit;
		}

		pre a::before {
		  content: counter(line-numbering);
		  counter-increment: line-numbering;
		  padding-right: 1em; /* space after numbers */
		  width: 25px;
		  text-align: right;
		  opacity: 0.7;
		  display: inline-block;
		  color: #aaa;
		  background: #eee;
		  margin-right: 16px;
		  padding: 2px 10px;
		  font-size: 13px;
		  -webkit-touch-callout: none;
		  -webkit-user-select: none;
		  -khtml-user-select: none;
		  -moz-user-select: none;
		  -ms-user-select: none;
		  user-select: none;
		}

		pre a:first-of-type::before {
		  padding-top: 10px;
		}

		pre a:last-of-type::before {
		  padding-bottom: 10px;
		}

		pre a:only-of-type::before {
		  padding: 10px;
		}

		.highlight { background-color: #ffffcc } /* RIGHT */
		</style>
  </head>
  <body>
	  <div>
				<div style='width:25%;'>
						<ul id="tree" class="ztree" style='width:100%'>

						</ul>
				</div>
        <div id='readme' style='width:70%;margin-left:20%;'>
          	<article class='markdown-body'>
            	<h1 id="-">课程介绍</h1>
<h2 id="-">课程大纲</h2>
<p><img src="./gmedia/dagang.png" alt="课程大纲"></p>
<h2 id="-">学习目标</h2>
<ul>
<li>理解面向对象开发思想</li>
<li>掌握 JavaScript 面向对象开发相关模式</li>
<li>掌握在 JavaScript 中使用正则表达式</li>
</ul>
<h2 id="-">学习资源</h2>
<ul>
<li>JavaScript 高级程序设计（第三版）<ul>
<li>前端的红宝书</li>
<li>建议每一个前端都完整的看一遍</li>
</ul>
</li>
<li>JavaScript面向对象编程指南（第2版）</li>
<li>JavaScript面向对象精要</li>
<li>JavaScript 权威指南</li>
<li>JavaScript 语言精粹</li>
<li>你不知道的 JavaScript</li>
</ul>
<h1 id="-">面向对象编程</h1>
<p><img src="./gmedia/mxdxkf.png" width="400" alt=""></p>
<h2 id="-">基本概念</h2>
<h3 id="-">什么是对象？</h3>
<blockquote>
<p>Everything is object （万物皆对象）</p>
</blockquote>
<p><img src="./gmedia/20160823024542444.jpg" alt=""></p>
<p>对象到底是什么，我们可以从两次层次来理解。</p>
<p><strong>(1) 对象是具体事物的抽象。</strong></p>
<p>一本书、一辆汽车、一个人都可以是对象，当实物被抽象成对象，实物之间的关系就变成了对象之间的关系，从而就可以模拟现实情况，针对对象进行编程。</p>
<p>问： 书是对象吗</p>
<p><strong>(2)对象是无序键值对的集合，其属性可以包含基本值、对象或者函数</strong></p>
<p>每个对象都是基于一个引用类型创建的，这些类型可以是系统内置的原生类型，也可以是开发人员自定义的类型。</p>
<h3 id="-">什么是面向对象？</h3>
<p>面向对象编程 —— Object Oriented Programming，简称 OOP ，是一种编程开发思想。</p>
<p>在面向对象程序开发思想中，每一个对象都是功能中心，具有明确分工，可以完成接受信息、处理数据、发出信息等任务。
因此，面向对象编程具有灵活、代码可复用、高度模块化等特点，容易维护和开发，比起由一系列函数或指令组成的传统的过程式编程（procedural programming），更适合多人合作的大型软件项目。</p>
<p>面向对象与面向过程：</p>
<ul>
<li>面向过程就是亲历亲为，事无巨细，有条不紊，面向过程是解决问题的一种思维方式，（执行者的角度）<ul>
<li>关注点在于解决问题的过程（先xx，然后xx，在xx）；</li>
</ul>
</li>
<li>面向对象就是找一个对象，让她去做这件事情（指挥者的角度）<ul>
<li>关注点在找到能解决问题的对象上。</li>
</ul>
</li>
<li>面向对象不是面向过程的替代，而是面向过程的封装</li>
<li>例如洗衣服（面向过程和面向对象的区别）</li>
</ul>
<p>面向对象的特性：</p>
<ul>
<li>封装性<ul>
<li>将功能的具体实现，全部封装到对象的内部，外界使用对象时，只需要关注对象提供的方法如何使用，而不需要关心对象的内部具体实现，这就是封装。</li>
</ul>
</li>
<li>继承性<ul>
<li>在js中，继承的概念很简单，一个对象没有的一些属性和方法，另外一个对象有，拿过来用，就实现了继承。</li>
<li><strong>注意：在其他语言里面，继承是类与类之间的关系，在js中，是对象与对象之间的关系。</strong></li>
</ul>
</li>
<li>[多态性]<ul>
<li>多态是在强类型的语言中才有的。js是弱类型语言，所以JS不支持多态（强类型语言具有多态性）</li>
</ul>
</li>
</ul>
<h2 id="-">创建对象的方式</h2>
<h3 id="-">内置构造函数创建</h3>
<p>我们可以直接通过 <code>new Object()</code> 创建：</p>
<pre><code class="lang-javascript">//在js中，对象有动态特性，可以随时的给一个对象增加属性或者删除属性。
var person = new Object()
person.name = &#39;Jack&#39;
person.age = 18

person.sayName = function () {
  console.log(this.name)
}
</code></pre>
<p>缺点：麻烦，每个属性都需要添加。</p>
<h3 id="-">对象字面量创建</h3>
<pre><code class="lang-javascript">var person = {
  name: &#39;Jack&#39;,
  age: 18,
  sayName: function () {
    console.log(this.name)
  }
}
</code></pre>
<p>缺点：如果要批量生成多个对象，应该怎么办?代码很冗余</p>
<h3 id="-">简单改进：工厂函数</h3>
<p>我们可以写一个函数，解决代码重复问题：</p>
<pre><code class="lang-javascript">function createPerson (name, age) {
  return {
    name: name,
    age: age,
    sayName: function () {
      console.log(this.name)
    }
  }
}
</code></pre>
<p>然后生成实例对象：</p>
<pre><code class="lang-javascript">var p1 = createPerson(&#39;Jack&#39;, 18)
var p2 = createPerson(&#39;Mike&#39;, 18)
</code></pre>
<p>缺点：但却没有解决对象识别的问题，创建出来的对象都是Object类型的。</p>
<h3 id="-">继续改进：构造函数</h3>
<p>构造函数是一个函数，用于实例化对象，需要配合new操作符使用。</p>
<pre><code class="lang-javascript">function Person (name, age) {
  this.name = name
  this.age = age
  this.sayName = function () {
    console.log(this.name)
  }
}

var p1 = new Person(&#39;Jack&#39;, 18)
p1.sayName() // =&gt; Jack

var p2 = new Person(&#39;Mike&#39;, 23)
p2.sayName() // =&gt; Mike
</code></pre>
<p>而要创建 <code>Person</code> 实例，则必须使用 <code>new</code> 操作符。
以这种方式调用构造函数会经历以下 4 个步骤：</p>
<ol>
<li>创建一个新对象</li>
<li>将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象）</li>
<li>执行构造函数中的代码</li>
<li>返回新对象</li>
</ol>
<p><strong>构造函数需要配合new操作符使用才有意义，构造函数首字母都需要大写</strong></p>
<p>术语：</p>
<ol>
<li>实例（对象）：通过构造函数创建出来的对象，实例可以若干个</li>
<li>实例化：构造函数创建对象的过程</li>
<li>成员：对象的属性和方法</li>
</ol>
<h3 id="-">构造函数的缺点</h3>
<p>使用构造函数带来的最大的好处就是创建对象更方便了，但是其本身也存在一个浪费内存的问题：</p>
<pre><code class="lang-javascript">function Person (name, age) {
  this.name = name
  this.age = age
  this.type = &#39;human&#39;
  this.sayHello = function () {
    console.log(&#39;hello &#39; + this.name)
  }
}

var p1 = new Person(&#39;lpz&#39;, 18)
var p2 = new Person(&#39;Jack&#39;, 16)
console.log(p1.sayHello === p2.sayHello) // =&gt; false
</code></pre>
<p>解决方案：</p>
<pre><code class="lang-javascript">function sayHello() {
  console.log(&#39;hello &#39; + this.name)
}

function Person (name, age) {
  this.name = name
  this.age = age
  this.type = &#39;human&#39;
  this.sayHello = sayHello
}

var p1 = new Person(&#39;lpz&#39;, 18)
var p2 = new Person(&#39;Jack&#39;, 16)

console.log(p1.sayHello === p2.sayHello) // =&gt; true
</code></pre>
<p>缺点：会暴漏很多的函数，容易造成全局变量污染。解决方案（把方法集中放置到一个对象中）</p>
<h2 id="-">原型</h2>
<h3 id="-">原型基本概念</h3>
<p>Javascript 规定，每一个<strong>函数</strong>都有一个 <code>prototype</code> 属性，指向另一个对象。这个对象我们把它叫做原型（原型对象）</p>
<p>原型的作用：能够解决构造函数造成的内存浪费的问题</p>
<p>这个对象的所有属性和方法，都会被构造函数的实例继承。</p>
<p>这也就意味着，我们可以把所有对象实例需要共享的属性和方法直接定义在 <code>prototype</code> 对象上。</p>
<pre><code class="lang-javascript">function Person (name, age) {
  this.name = name
  this.age = age
}

console.log(Person.prototype)

Person.prototype.type = &#39;human&#39;

Person.prototype.sayName = function () {
  console.log(this.name)
}

var p1 = new Person(...)
var p2 = new Person(...)

console.log(p1.sayName === p2.sayName) // =&gt; true
</code></pre>
<p>这时所有实例的 <code>type</code> 属性和 <code>sayName()</code> 方法，其实都是同一个内存地址</p>
<h3 id="-">构造函数、实例、原型三者之间的关系</h3>
<p>构造函数：构造函数就是一个函数，配合new可以新建对象。</p>
<p>实例：通过构造函数实例化出来的对象我们把它叫做构造函数的实例。一个构造函数可以有很多实例。</p>
<p>原型：每一个构造函数都有一个属性<code>prototype</code>，函数的prototype属性值就是原型。通过构造函数创建出来的实例能够直接使用原型上的属性和方法。</p>
<p><img src="./gmedia/原型三角关系.jpg" alt=""></p>
<p>思考：内置对象中，有很多的方法，这些方法存在哪里？</p>
<h3 id="__proto__-"><code>__proto__</code>（不推荐）</h3>
<p>任意一个<strong>对象</strong>，都会有<code>__proto__</code>属性，这个属性指向了构造函数的prototype属性，也就是原型对象。</p>
<p>获取原型对象：</p>
<ul>
<li>通过<code>构造函数.prototype</code>可以获取</li>
<li>通过<code>实例.__proto__</code>可以获取（隐式原型）</li>
<li>它们指向了同一个对象<code>构造函数.prototype === 实例.__proto__</code></li>
</ul>
<p><strong>注意：<code>__proto__</code>是浏览器的一个隐藏（私有）属性，IE浏览器不支持，不要通过它来修改原型里的内容，如果要修改原型中的内容，使用构造函数.prototype去修改</strong></p>
<h3 id="constructor-">constructor属性</h3>
<p>默认情况下，原型对象中只包含了一个属性：constructor，constructor属性指向了当前的构造函数。</p>
<p><img src="gmedia\sanjiao.png" alt="sanjiao"></p>
<h2 id="-">原型链</h2>
<h3 id="-">原型链概念</h3>
<p>任何一个对象，都有原型对象，原型对象本身又是一个对象有<code>__proto__</code>属性，所以原型对象也有自己的原型对象，这样一环扣一环就形成了一个链式结构，我们把这个链式结构称为：原型链。</p>
<p>绘制对象的原型链结构：</p>
<pre><code class="lang-javascript">//1. var p = new Person();
//2. var o = new Object();
//3. var arr = new Array();
//4. var date = new Date();
//5. Math
//6. 查看一个div的原型链结构
</code></pre>
<p>总结：Object.prototype是原型链的尽头，Object.prototype的原型是null。</p>
<p><img src="gmedia/proto.png" alt=""></p>
<h3 id="-">属性查找原则</h3>
<p>如果是获取操作</p>
<ol>
<li>会先在自身上查找，如果没有</li>
<li>则根据<code>__proto__</code>对应的原型去找，如果没有</li>
<li>一直找到<code>Object.prototyp</code>，如果没有，那就找不到了。</li>
</ol>
<p>如果是修改操作：</p>
<p>只会修改对象自身的属性，如果自身没有这个属性，那么就会添加这个属性，并不会修改原型中的属性。</p>
<h3 id="object-">Object原型上常用的成员</h3>
<h4 id="hasownproperty-">hasOwnProperty方法</h4>
<p>作用：判断该属性是否是该对象自身的，如果是返回true</p>
<h4 id="in-for-in-">in运算法 for...in...</h4>
<p>语法： 属性 in 对象</p>
<p>作用：对象能否访问该属性，如果可以返回true</p>
<p>使用场景：使用在for... in...遍历对象中，过滤出自身属性。</p>
<h1 id="-">继承</h1>
<blockquote>
<p>继承：子承父业</p>
</blockquote>
<p>在js中的继承概念非常简单，拿来主义：一个对象自己没有的属性和方法，另一个对象有，拿过来使用，就实现了继承。</p>
<p>继承的目的：让一个对象可以使用另一个对象的属性和方法。</p>
<p>JS常见的几种继承模式：</p>
<h2 id="-mixin-">混入式继承（mixin）</h2>
<blockquote>
<p>把一个对象中的属性和方法拷贝到另一个对象中。</p>
</blockquote>
<pre><code class="lang-javascript">var ff = {
    name:&quot;飞飞&quot;,
    extend: function(obj) {
        for(var k in obj) {
            this[k] = obj[k];
        }
    }
}
</code></pre>
<h2 id="-">原型链继承</h2>
<p>一个对象可以访问构造函数的原型中的属性和方法，那么如果想要让一个对象增加某些属性和方法，</p>
<p>只需要把这些属性和方法放到原型对象中即可。这样就实现了继承, 称之为原型链继承</p>
<ul>
<li><p>直接给原型增加属性和方法</p>
</li>
<li><p>原型替换（注意：constructor）</p>
</li>
</ul>
<pre><code class="lang-javascript">  // 原型链继承的另外写法： 原型替换
//  原型替换问题：会造成constructor属性丢失
Person.prototype = {
// 解决方案： 给新对象手动添加constructor属性指向当前的构造函数
    constructor: Person,
    color: &quot;red&quot;,
    legs: 2,
    sayHi: function () {
        console.log(&quot;hi&quot;);
    }
};
 var p2 = new Person();
console.log(p2.color);
</code></pre>
<ul>
<li>mixin+原型替换</li>
</ul>
<pre><code class="lang-javascript">    function Person(){}

          var haohao = {
              car: &quot;法拉利&quot;,
              money: 1000000000,
              house: &quot;新疆海景房&quot;
          }

          var dafeige = {
              handsome: &quot;very handsome&quot;,
              youm: &quot;幽默的男人&quot;
          }

          // 需求：让Person的所有实例对象可以继承到haohao  dafeige 所有成员。

          // 混入 + 原型链继承一起使用
          // 混入： 把dafeige 等 添加给 Person的原型
          // 原型链： Person的所有实例对象 原型链继承到 原型上的成员

Person.prototype.extend = function (obj) {
   for(var k in obj){
    if(obj.hasOwnProperty(k)){
      this[k] = obj[k];
        }
    }
}
// extend 方法是被Person.prototype 调用了，所以extend 方法内部的this指向Person.prototype
//  this 谁调用，指向谁。 
          Person.prototype.extend(haohao);
 Person.prototype.extend(dafeige);

          var p1 = new Person();
          var p2 = new Person();

          console.log(p1.car);
</code></pre>
<h2 id="-object-create">经典继承Object.create</h2>
<blockquote>
<p>最初是由道格拉斯丶克罗克福德发布的一篇文章提出的，ECMAScript5新增了Object.create()方法来规范化了这种继承。</p>
</blockquote>
<p>ES5中新增了一个方法<code>Object.create()</code>,方法会使用指定的原型对象及其属性去创建一个新的对象。</p>
<pre><code class="lang-javascript">//参数：proto 一个对象
//返回值：obj 新对象，新对象的原型就是proto
var obj = Object.create(proto);
console.log(obj);
</code></pre>
<h2 id="-">其他继承方式</h2>
<h3 id="-">借用构造函数继承</h3>
<pre><code class="lang-javascript">function Person(name,age,gender){
    this.name = name;
    this.age = age;
    this.gender = gender;
}
function Chinese(name,age,gender,skin){
    //借用构造函数继承，这里的this指向当前调用的实例对象xm
    Person.call(this,name,age,gender);
    this.skin = skin||&quot;黄色&quot;；
}
var xm = new Chinese(&quot;xm&quot;,20,&quot;male&quot;,&quot;黄色&quot;)；
console.log(xm);
</code></pre>
<p>注意：使用call方法借用构造函数方法，查看下方上下文方法（方法借用）中的call方法。</p>
<h3 id="-">组合继承</h3>
<ol>
<li>借用构造函数继承 ，继承构造函数内的属性</li>
<li>原型链继承，继承构造函数原型的方法</li>
</ol>
<pre><code class="lang-javascript">Person.prototype.sayHi = function(){
    console.log(&quot;hello,我是&quot;+this)
}

//原型替换，把Person.prototype地址拷贝给Chinese.prototype，修改Chinese.prototype也会影响到Person.prototype
//Chinese.prototype = Person.prototype；
//解决方案
Chinese.prototype = new Person();

//修复原型替换后constructor属性丢失问题，手动修改constructor
Chinese.prototype.constructor = Chinese；
</code></pre>
<h1 id="-">函数进阶</h1>
<h2 id="-">定义函数的三种方式</h2>
<h3 id="-">函数声明</h3>
<pre><code class="lang-javascript">fn();//函数声明可以先调用，在声明
function fn(){
  console.log(&quot;这是函数声明&quot;)
}
</code></pre>
<h3 id="-">函数表达式</h3>
<pre><code class="lang-javascript">var fn = function() {
  console.log(&quot;这是函数表达式&quot;);  
}
fn();//函数表达式必须先声明，再调用
</code></pre>
<h3 id="-function">构造函数Function</h3>
<pre><code class="lang-javascript">//函数也是对象，可以使用Function构造函数new出来
//相当于var fn = function(){}
var fn = new Function();

//语法：new Function(arg1,arg2,arg3..,body);
// 1. 所有的参数都是字符串类型。
// 2. 前面可以定义任意多个形参，最后一个参数是代码体。
var fn = new Function(&quot;alert(1111)&quot;);
fn();

var fn1 = new Function(&quot;a1&quot;, &quot;a2&quot;, &quot;alert(a1+a2)&quot;);
fn1(1,2);
</code></pre>
<p>【案例：代码实时预览效果.html】</p>
<p>try-catch捕获错误方法</p>
<h2 id="eval-">eval函数--了解</h2>
<blockquote>
<p>eval的可以和new Function一样，执行字符串代码</p>
</blockquote>
<p>注意：eval函数的功能非常的强大，但是实际使用的情况并不多。</p>
<ul>
<li>eval形式的代码难以阅读</li>
<li>eval形式的代码无法打断点，因为本质还是还是一个字符串</li>
<li>在浏览器端执行任意的 JavaScript会带来潜在的安全风险，恶意的JavaScript代码可能会破坏应用，特别是在用它执行用户输入数据的情况下。否则，可能会有恶意用户输入威胁你的站点或应用程序安全的代码（即所谓的代码注入）
<a href="http://qingbob.com/Excess-XSS/">推荐了解下xss攻击</a></li>
</ul>
<h2 id="-">函数的四种调用模式</h2>
<blockquote>
<p>根据函数内部this的指向不同，可以将函数的调用模式分成4种</p>
</blockquote>
<ol>
<li>函数调用模式</li>
<li>方法调用模式</li>
<li>构造函数调用模式</li>
<li>上下文调用模式（借用方法模式）</li>
</ol>
<pre><code class="lang-javascript">函数：当一个函数不是一个对象的属性时，我们称之为函数。
方法：当一个函数被保存为对象的一个属性时，我们称之为方法。
</code></pre>
<h3 id="-">函数调用模式</h3>
<font color="red">如果一个函数不是一个对象的属性时，就是被当做一个函数来进行调用的。此时this指向了window</font>

<pre><code class="lang-javascript">function fn(){
  console.log(this);//指向window
}
fn();
</code></pre>
<h3 id="-">方法调用模式</h3>
<font color="red">当一个函数被保存为对象的一个属性时，我们称之为一个方法。当一个方法被调用时，this被绑定到当前对象</font>

<pre><code class="lang-javascript">var obj = {
  sayHi:function(){
    console.log(this);//在方法调用模式中，this指向调用当前方法的对象。
  }
}
obj.sayHi();
</code></pre>
<h3 id="-">构造函数调用模式</h3>
<font color="red">如果函数是通过new关键字进行调用的，此时this被绑定到创建出来的新对象上。</font>

<pre><code class="lang-javascript">function Person(){
  console.log(this);
}
Person();//this指向什么？
var p = new Person();//this指向什么？
</code></pre>
<p><strong>总结：分析this的问题，主要就是区分函数的调用模式，看函数是怎么被调用的。</strong></p>
<ul>
<li>猜猜看：</li>
</ul>
<pre><code class="lang-javascript">//分析思路：1. 看this是哪个函数的  2. 看这个函数是怎么调用的，处于什么调用模式
//题目一：
var age = 38;
var obj = {
    age: 18,
    getAge: function () {
        console.log(this.age);
    }
}

var f = obj.getAge;
f();//???
// 38

//题目二
var age = 38;
var obj = {
  age:18,
  getAge:function () {
    console.log(this.age);//???
    function foo(){
      console.log(this.age);//????
    }
    foo();
  }
}
obj.getAge();
obj[&quot;getAge&quot;]();
// 18 18

//题目三：
var length = 10;
var age = 18;
function fn() {
    console.log(this.length);
}
var arr = [fn, &quot;222&quot;];
fn();
arr[0]();
// 10 2
//题目四：
// 面试题5:
var length = 10

function fn() {
    console.log(this.length)
}
var obj = {
    length: 5,
    method: function (fn) {
        fn() 
        arguments[0]();
    }
}
obj.method(fn, 10, 5);
//10 3
//arguments实参列表里面可以访问到所有实参
</code></pre>
<p>几种特殊的this指向</p>
<ul>
<li>定时器中的this指向了window，因为定时器的function最终是由window来调用的。</li>
<li>事件中的this指向的是当前的元素，在事件触发的时候，浏览器让当前元素调用了function</li>
</ul>
<h3 id="-">上下文调用模式（方法借用）</h3>
<blockquote>
<p>上下文调用模式也叫方法借用模式，分为apply与call</p>
<p>使用方法： 函数.call() 或者 函数.apply()</p>
</blockquote>
<h4 id="call-">call方法</h4>
<p>call方法可以调用一个函数，并且可以指定这个函数的<code>this</code>指向</p>
<pre><code class="lang-javascript">//所有的函数都可以使用call进行调用
//参数1：指定函数的this，如果不传，则this指向window
//其余参数：和函数的参数列表一模一样。
//说白了，call方法也可以和()一样，进行函数调用，call方法的第一个参数可以指定函数内部的this指向。
fn.call(thisArg, arg1, arg2, arg2);
</code></pre>
<ul>
<li>借用对象的方法</li>
</ul>
<h4 id="-">伪数组与数组</h4>
<blockquote>
<p>伪数组也叫类数组</p>
</blockquote>
<ol>
<li>伪数组其实就是一个对象，但是跟数组一样，伪数组也会有<code>length</code>属性，也有<code>0,1,2,3</code>等属性。</li>
<li>伪数组并没有数组的方法，不能使用<code>push/pop</code>等方法</li>
<li>伪数组可以跟数组一样进行遍历，通过下标操作。</li>
<li>常见的伪数组：<code>arguments</code>实参列表、<code>document.getElementsByTagName的返回值</code>、<code>jQuery对象</code></li>
</ol>
<pre><code class="lang-javascript">var arrayLike = {
  0:&quot;张三&quot;,
  1:&quot;李四&quot;,
  2:&quot;王五&quot;,
  length:3
}
//伪数组可以和数组一样进行遍历
</code></pre>
<ul>
<li>伪数组借用数组的方法</li>
</ul>
<pre><code class="lang-javascript">Array.prototype.push.call(arrLike, &quot;赵六&quot;);
//注意：方法存储在哪就去哪里获取方法
//方法精简
[].push.call(arrLike, &quot;赵六&quot;);
//注意简写形式[]前一句结尾需要使用分号“ ；”，否则语法错误，表示为没有下标
</code></pre>
<ul>
<li>将伪数组转换成真数组</li>
</ul>
<pre><code class="lang-javascript">var arr = Array.prototype.slice.call(arrLike);
//方法精简
[].slice.call(arrLike);
//注意简写形式[]前一句结尾需要使用分号“ ；”，否则语法错误，表示为没有下标
</code></pre>
<h4 id="apply-">apply方法</h4>
<p><code>apply()</code>方法的作用和 <code>call()</code>方法类似，只有一个区别，就是<code>apply()</code>方法接受的是<strong>一个包含多个参数的数组</strong>。而<code>call()</code>方法接受的是<strong>若干个参数的列表</strong></p>
<p>apply的平铺性：把数组平铺展开，取数组中的每一项，每一项会作为函数的实参。</p>
<pre><code class="lang-javascript">//fn.apply(thisArg，实参列表);
fn.apply(thisArg，[参数1，参数2，...参数n]);
</code></pre>
<p>call和apply的使用场景：</p>
<ul>
<li>如果参数比较少，使用call会更加简洁</li>
<li>如果参数存放在数组中，此时需要使用apply</li>
</ul>
<p>课后练习：</p>
<pre><code class="lang-javascript">1. 求数组的最大值和最小值
//使用arr借用Math的max方法
var arr = [15,81,82,11,33,21];
var res = Math.max.apply(arr,arr);
console.log(res);

2.封装console.log方法
//函数实参列表argument
function clg(){
    //每次输出前面都有友情提示
    [].unshift(argument，&quot;友情提示&quot;);
    consloe.log.apply(argument,argument)
}；
clg(&quot;haohao&quot;,&quot;haha&quot;)
</code></pre>
<h4 id="bind-">bind方法</h4>
<p><strong>bind()</strong>方法创建一个新的函数, 可以绑定新的函数的<code>this</code>指向</p>
<pre><code class="lang-javascript">// 返回值：新的函数,和原函数几乎一下，this指向无法改变了
// 参数：新函数的this指向，当绑定了新函数的this指向后，无论使用何种调用模式，this都不会改变。
var newFn = fn.bind(thisArg);
</code></pre>
<h2 id="-">函数也是对象</h2>
<blockquote>
<p>函数是由new Function创建出来的，因此函数也是一个对象， <code>所有的函数都是new Function的实例</code>。</p>
</blockquote>
<h3 id="-">函数的原型链结构</h3>
<p>画出下列代码的原型链结构</p>
<pre><code class="lang-javascript">//var Person = new Function();
function Person(){

}
</code></pre>
<p><img src="gmedia/function.jpg" alt=""></p>
<h3 id="function-prototype-">Function.prototype常用成员</h3>
<ul>
<li>call：调用函数，重新指向this</li>
<li>apply：调用函数，重新指向this</li>
<li>bind：重新指向this，返回一个新的函数，不调用。</li>
</ul>
<h3 id="-">完整版原型链</h3>
<blockquote>
<p>绘制完整版原型链的目的是辅助大家理解js中对象的继承关系。</p>
</blockquote>
<p><img src="gmedia/full.png" alt=""></p>
<p>总结：</p>
<ol>
<li><p>所有函数都是new Function创建出来的，因此<code>所有函数.__proto__</code>都是<code>Function.prototype</code></p>
</li>
<li><p>所有对象都是new Object创建出来的，因此<code>所有对象.__proto__</code>都是<code>Object.prototyp</code></p>
</li>
</ol>
<h2 id="instanceof-">instanceof 用来检测复制数据类型</h2>
<p>语法：对象 instanceof 构造函数</p>
<p>作用：需要站在原型链角度去理解，判断构造函数的prototype属性是否在对象的原型链上，如果在返回true</p>
<h2 id="-">作用域</h2>
<blockquote>
<p>作用域：变量起作用的区域，也就是说：变量定义后，可以在哪个范围内使用该变量。</p>
</blockquote>
<pre><code class="lang-javascript">var num = 11;//全局变量
function fn(){
  var num1 = 22;//局部变量
  console.log(num);  // 全局变量在任何地方都能访问到
  console.log(num1);  
}
console.log(num);
</code></pre>
<p>JS中没有块级作用域。</p>
<p>在js里只有函数可以形成作用域，叫做函数作用域。</p>
<p>因为函数能够形成作用域，所以，函数内部声明的变量函数外部无法访问。</p>
<p>函数作用域是在函数定义的时候作用域就确定下来了，和函数在哪调用无关。</p>
<pre><code class="lang-javascript">var num = 123;
function f1() {
  console.log(num);
}

function f2(){
  var num = 456;
  f1();
}
f2();//打印啥？
</code></pre>
<h3 id="-">作用域链</h3>
<blockquote>
<p>作用域链：只要是函数，就会形成一个作用域，如果这个函数被嵌套在其他函数中，那么外部函数也有自己的作用域，这个一直往上到全局环境，就形成了一个作用域链。</p>
</blockquote>
<p><code>变量的搜索原则</code>：</p>
<ol>
<li>从当前作用域开始查找是否声明了该变量，如果存在，那么就直接返回这个变量的值。</li>
<li>如果不存在，就会往上一层作用域查询，如果存在，就返回。</li>
<li>如果不存在，一直查询到全局作用域，如果存在，就返回。如果在全局中也没有找到该变量会报错</li>
</ol>
<h3 id="-">作用域链练习</h3>
<pre><code class="lang-javascript">// 1 
var num = 10;
fn1();
function fn1() {
  console.log(num);  // ?
  var num = 20;
  console.log(num);  // ?
}
console.log(num);    // ?


// 2 -- 改造上面的面试题
var num = 10;
fn1();
function fn1() {
  console.log(num);  // ?
  num = 20;
  console.log(num);  // ?
}
console.log(num);    // ?


// 3
var num = 123
function f1(num) {
    console.log(num) // ?
}

function f2() {
    var num = 456
    f1(num)
}
f2()


// 4
var num1 = 10;
var num2 = 20;
function fn(num1) {
  num1 = 100;
  num2 = 200;
  num3 = 300;
  console.log(num1);
  console.log(num2);
  console.log(num3);
  var num3;
}
fn();
console.log(num1);
console.log(num2);
console.log(num3);


// 5
var num = 1;
function fn(){
  var num = 100;
  num++;
  console.log(num);
}
fn();
fn();
console.log(num);


// 6.
var color = &quot;red&quot;;
function outer() {
    var anotherColor = &quot;blue&quot;;

    function inner() {
        var tmpColor = color;
        color = anotherColor;
        anotherColor = tmpColor;
        console.log(anotherColor);
    }

    inner();
}
outer();
console.log(color);
</code></pre>
<h2 id="-">递归函数</h2>
<blockquote>
<p>递归函数：函数内部直接或者间接的调用自己</p>
</blockquote>
<p>递归的要求：</p>
<ol>
<li>自己调用自己（直接或者间接）</li>
<li>要有结束条件（出口）</li>
</ol>
<p>递归函数主要是<code>化归思想</code> ,将一个复杂的问题简单化，主要用于解决数学中的一些问题居多。</p>
<ul>
<li>把要解决的问题，归结为已经解决的问题上。</li>
<li>一定要考虑什么时候结束让函数结束，也就是停止递归（一定要有已知条件）</li>
</ul>
<p>练习：</p>
<ul>
<li>计算1-100之间所有数的和</li>
</ul>
<pre><code class="lang-javascript">  function sum (n){
      if(n===1){
          return 1;
      }
      return sum(n-1) + 100;
  }
</code></pre>
<ul>
<li>计算斐波那契数列</li>
</ul>
<pre><code class="lang-javascript">function fib(n){
    if(n&lt;=0){
        return -1;
    }
    if(n == 1 || n==2){
        return 1;
    }
    return fib(n - 1) + fib(n - 2);
}
</code></pre>
<p>斐波那契数列优化版：</p>
<pre><code class="lang-JavaScript">//使用缓存记录计算数据减少运算负担
//1、建立缓存容器
var cache = {
    //缓存中，键表示月份，值表示只数
    /*1:1,
      2:1,*/   
}
function fib(n){
    if(n&lt;=0){
        return -1;
    }
    if(n == 1 || n==2){
        return 1;
    }
    if(cache[n]){
        //如果成立说明缓存中没有
        //返回缓存的结果
        return cache[n];
    }
    else{
        var ret = fib(n - 1) + fib(n - 2);
        //把计算结果存入缓存容器
        cache[n] = ret;
        //把计算结果返回
        return ret;
    }
}

</code></pre>
<p>注意递归运算return返回值是层层递进，然后层层递归。</p>
<h1 id="-">闭包</h1>
<h2 id="-">闭包的基本概念</h2>
<p>  <code>闭包（closure）</code>是JavaScript语言的一个难点，也是JavaScript的一个特色，很多高级的应用都要依靠闭包来实现。</p>
<h3 id="-">作用域</h3>
<p>  在js中，函数会形成函数作用域，在函数内部可以直接访问全局变量</p>
<pre><code>  var str = &quot;zs&quot;;
  function fn(){
    console.log(str);//访问全局变量
  }
  fn();//zs
</code></pre><p>  在函数外部却无法访问函数内部的变量</p>
<pre><code>  function fn(){
    var str = &quot;zs&quot;;
  }
  fn();
  console.log(str);//报错 str is not defined
</code></pre><p>  问题：我怎么才能获取到函数内部的变量？</p>
<h3 id="-">作用域链</h3>
<p>  在函数内部有一个函数，那么函数内部的函数是可以访问到外部函数的变量的。</p>
<p>  解决方法：</p>
<pre><code>  function fn(){
    var str = &quot;zs&quot;;
    function f2(){
      console.log(str);
    }
    f2();
  }
  fn();
</code></pre><p>  在上述代码中，fn中定义的所有变量，对于f2函数都来都是可以访问的。但是现在f2在函数的内部，我们如何在外部访问到f2这个函数呢？</p>
<pre><code>  function fn(){
    var str = &quot;zs&quot;;
    function f2(){
      console.log(str);
    }
    return f2;
  }
  var result = fn();
  result();// &quot;zs&quot;
</code></pre><h3 id="-">闭包的概念</h3>
<blockquote>
<p>闭包是函数和声明该函数的词法环境的组合。 （closure)</p>
</blockquote>
<p>  在JavaScript中，在函数中可以（嵌套）定义另一个函数时,内部的函数引用了外部的函数的变量，产生闭包。</p>
<p>  <strong>闭包中包含了内部函数的代码，以及所需外部函数中的变量的引用</strong> </p>
<p>  产生闭包的条件</p>
<pre><code>  当内部函数访问了外部函数的变量的时候，就会形成闭包。
</code></pre><p>  闭包的作用：</p>
<ol>
<li><p>私有变量，保护数据安全</p>
<p>外部全局无法改变闭包的值，需要调用闭包函数修改</p>
</li>
<li><p>持久化维持数据</p>
<p>每次调用闭包都会重新开辟新的空间</p>
<h2 id="-">闭包的应用</h2>
<h3 id="-">计数器</h3>
<p>需求：统计一个函数的调用次数</p>
<pre><code>var count = 0;
function fn(){
count++;
console.log(&quot;我被调用了，调用次数是&quot;+count);
}
fn();
fn();
fn();
</code></pre><p>缺点：count是全局变量，不安全。</p>
<p>使用闭包解决这个问题！！！！</p>
<pre><code>function outer(){
var count = 0; // 私有变量, 将count保护起来了
function add(){
 count++;
 console.log(&quot;当前count&quot;+count);
}
return add;
}

var result = outer();
result();
</code></pre><p>【银行存钱取钱.html】</p>
<h3 id="-">实现缓存</h3>
<blockquote>
<p>缓存（cache）：数据的缓冲区，当要读取数据时，先从缓冲中获取数据，如果找到了，直接获取，如果找不到，重新去请求数据。</p>
</blockquote>
<p>计算斐波那契数列，会有很大的性能问题，因为重复的计算了很多次，因此我们可以使用缓存来解决这个性能问题。</p>
<p>初级优化：</p>
<p>使用缓存的基本步骤：</p>
</li>
<li><p>如果要获取数据，先查询缓存，如果有就直接使用</p>
</li>
<li><p>如果没有，就进行计算，并且将计算后的结果放到缓存中，方便下次使用。</p>
<pre><code>//缓存
var arr = [];
var fbi = function (n) {
count++;
if (n == 1 || n == 2) {
  return 1;
}
if (arr[n]) {
  return arr[n];
} else {
  var temp = fbi(n - 1) + fbi(n - 2);
  arr[n] = temp;//存入缓存
  return temp;
}
}
</code></pre><p>缺点：既然使用缓存，就需要保证缓存的数据的安全，不能被别人修改，因此，需要使用闭包来实现缓存的私有化。</p>
<pre><code>function outer() {
//缓存
var arr = [];

var fbi = function (n) {
  if (n == 1 || n == 2) {
    return 1;
  }
  if (arr[n]) {
    return arr[n];
  } else {
    var temp = fbi(n - 1) + fbi(n - 2);
    arr[n] = temp;//存入缓存
    return temp;
  }
}
return fbi;
}
var fbi = outer();
console.log(fbi(40));
</code></pre><h2 id="-">闭包存在的问题</h2>
<blockquote>
<p>内存泄露：闭包占用的内存是不会被释放的，因此，如果滥用闭包，会造成内存泄漏的问题。闭包很强大，但是只有在必须使用闭包的时候才使用。</p>
</blockquote>
<h3 id="js-">js的垃圾回收机制</h3>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management</a></p>
</li>
<li><p>内存：计算机中所有程序的运行都是在<code>内存</code>中进行的，因此内存的性能对计算机的影响非常大，运行程序需要消耗内存，当程序结束时，内存会得到释放。</p>
</li>
<li>javascript分配内存：当我们定义变量，javascript需要分配内存存储数据。无论是值类型或者是引用类型，都需要存储在内存中。</li>
<li><p>垃圾回收：当代码执行结束，分配的内存已经不需要了，这时候需要将内存进行回收，在javascript语言中，<code>垃圾回收机器</code>会帮我们回收<code>不再需要使用</code>的内存。</p>
<h4 id="-">引用记数法清除</h4>
<p>引用记数垃圾收集：如果没有引用指向某个对象（或者是函数作用域），那么这个对象或者函数作用域就会被垃圾回收机制回收。</p>
<pre><code>var o = {
name:&quot;zs&quot;
}
//对象被o变量引用  ，引用记数1
var obj = o;   //变量被o和obj引用，引用记数2

o = 1;  //o不在引用对象了， 引用记数1
obj = null; //obj不在引用对象了，引用记数0，可以被垃圾回收了。
</code></pre></li>
</ol>
<p>注意：引用计数算法存在的问题循环引用</p>
<p>函数内两个对象互相引用，函数内的两个对象始终存在被调用2次，无法被回收</p>
<h4 id="-">标记清除法清除</h4>
<p>  使用引用计数法进行垃圾回收的时候，会出现循环引用导致内存泄漏的问题。因此现代的浏览器都采用标记清除法来进行垃圾回收。</p>
<p>  这个算法假定设置一个叫做根（root）的对象（在Javascript里，根是全局对象Window）。定期的，垃圾回收器将从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象……从根开始，垃圾回收器将找到所有可以获得的对象和所有不能获得的对象。 </p>
<p>  <strong>从2012年起，所有现代浏览器都使用了标记-清除垃圾回收算法。</strong> </p>
<h3 id="-">闭包占用内存释放</h3>
<pre><code>  function outer(){
    var count = 0;

    function fn(){
      count++;
      console.log(&quot;执行次数&quot;+count);
    }
    return fn;
  }


  var result = outer();
  result();
  result = null;//当函数fn没有被变量引用了，那么函数fn就会被回收，函数fn一旦被回收，那么outer调用形成的作用域也就得到了释放。
</code></pre><h1 id="-">正则表达式</h1>
<blockquote>
<p>正则表达式：用于匹配规律规则的表达式，正则表达式最初是科学家对人类神经系统的工作原理的早期研究，现在在编程语言中有广泛的应用，经常用于表单校验，高级搜索等。</p>
</blockquote>
<h2 id="-">创建正则表达式</h2>
<p>  【07-正则表达式的创建.html】</p>
<p>  构造函数的方式</p>
<pre><code class="lang-javascript">  var regExp = new RegExp(/d/);
</code></pre>
<p>  正则字面量</p>
<pre><code class="lang-javascript">  var regExp = /d/;
</code></pre>
<p>  正则的使用</p>
<pre><code class="lang-javascript">  /d/.test(&quot;aaa1&quot;);
</code></pre>
<h3 id="-">正则的组成</h3>
<p>1、普通字符：   /a/ a就是普通字符，表示写的是什么就匹配什么</p>
<p>2、元字符：有含义的字符</p>
<h2 id="-">元字符</h2>
<blockquote>
<p>正则表达式由一些普通字符和元字符组成，普通字符包括大小写字母、数字等，而元字符则具有特殊的含义。</p>
</blockquote>
<h3 id="-">常见元字符</h3>
<p><img src="gmedia/yuan.png" alt="img"></p>
<p>只匹配小数点<code>/\./</code>  </p>
<p><code>|</code>表示或，优先级最低</p>
<p>  <code>()</code>优先级最高，表示分组</p>
<h3 id="-">字符类的元字符</h3>
<p>  <code>[]</code>在正则表达式中表示一个字符的位置，[]里面写这个位置可以出现的字符。</p>
<pre><code>  console.log(/[abc]/);//匹配a,b,c
</code></pre><p>  <code>[^]</code>在中扩号中的^表示非的意思。</p>
<pre><code>  //^表示该位置不可以出现的字符
  console.log(/[^abc]/);//匹配除了a，b，c以外的其他字符
</code></pre><p>  <code>[a-z]</code> <code>[1-9]</code>表示范围</p>
<pre><code>  console.log(/[a-z]/.test(&quot;d&quot;));//小写字母
  console.log(/[A-Z]/.test(&quot;d&quot;));//大写字母
  console.log(/[0-9]/.test(&quot;8&quot;));//数字
  console.log(/[a-zA-Z0-9]/);//所有的小写字母和大写字母以及数字
</code></pre><h3 id="-">边界类元字符</h3>
<blockquote>
<p>我们前面学习的正则只要有满足的条件的就会返回true，并不能做到精确的匹配。</p>
</blockquote>
<p>  【12-正则边界.html】</p>
<p>  ^表示开头   <strong>[]里面的^表示取反(非)</strong></p>
<p>  $表示结尾</p>
<pre><code>  console.log(/^chuan/.test(&quot;dachuan&quot;));//必须以chuan开头
  console.log(/chuan$/.test(&quot;chuang&quot;));//必须以chuan结尾
  console.log(/^chuan$/.test(&quot;chuan&quot;));//精确匹配chuan

  //精确匹配chuan,表示必须是这个
  console.log(/^chuan$/.test(&quot;chuanchuan&quot;));//fasle
</code></pre><h3 id="-">量词类元字符</h3>
<blockquote>
<p>量词用来控制出现的次数，一般来说量词和边界会一起使用</p>
</blockquote>
<p>  【13-正则量词.html】</p>
<ol>
<li><code>*</code>表示能够出现0次或者更多次，x&gt;=0;</li>
<li><code>+</code>表示能够出现1次或者多次，x&gt;=1</li>
<li><code>?</code>表示能够出现0次或者1次，x=0或者x=1</li>
<li><code>{n}</code>表示能够出现n次</li>
<li><code>{n,}</code>表示能够出现n次或者n次以上</li>
<li><p><code>{n,m}</code>表示能够出现n-m次</p>
<p>思考：如何使用{}来表示*+? </p>
<h2 id="-">正则的使用</h2>
<h3 id="-">正则测试</h3>
</li>
<li><p>验证座机</p>
<ul>
<li>比如010-12345678  0797-1234567</li>
<li>开头是3-4位，首位必须是0</li>
<li>-后面是7-8位</li>
</ul>
<pre><code>var phoneReg = /^0\d{2,3}-\d{7,8}$/;
</code></pre></li>
<li><p>验证姓名</p>
<ul>
<li>只能是汉字</li>
<li>长度2-6位之间</li>
<li>汉字范围[\u4e00-\u9fa5]</li>
</ul>
<pre><code>var nameReg = /^[\u4e00-\u9fa5]{2,6}$/;
</code></pre></li>
<li><p>验证QQ</p>
<ul>
<li>只能是数字</li>
<li>开头不能是0</li>
<li>长度为5-11位</li>
</ul>
<pre><code>var qqReg = /^[1-9]\d{4,10}$/;
</code></pre></li>
<li><p>验证手机</p>
<ul>
<li>11位数字组成</li>
<li>号段13[0-9] 147 15[0-9] 17[0178] 18[0-9]</li>
</ul>
<pre><code>var mobileReg = /^(13[0-9]|147|15[0-9]|17[0178]|18[0-9])\d{8}$/;
</code></pre></li>
<li><p>验证邮箱</p>
<ul>
<li>前面是字母或者数字</li>
<li>必须有@</li>
<li>@后面是字母或者数字</li>
<li>必须有.</li>
<li>.后面是字母或者数字</li>
</ul>
<pre><code>var emailReg = /^\w+@\w+(\.\w+)+$/;
</code></pre><h3 id="-">正则替换</h3>
</li>
</ol>
<p>修饰符：g 全局搜索，i 忽略大小写</p>
<pre><code class="lang-javascript">  var str = &quot;   123AD  asadf   asadfasf  adf  &quot;;
  //1  替换掉字符串中的所有空白
  var str2 = str.replace(/\s/g, &quot;&quot;);
  //2. 将所有的ad替换成xx
  //3. 将所有的ad/AD替换成xx

  var str = &quot;abc,efg,123,abc,123,a&quot;
  4. 所有的逗号替换成句号

  var jsonStr = &#39;[{&quot;name&quot;:&quot;张三&quot;,score:80},{&quot;name&quot;:&quot;张三&quot;,score:90},{&quot;name&quot;:&quot;张三&quot;,score:81}]&#39;; 
  5. 把所有成绩都修改成100分
</code></pre>
<h1 id="jquery-">jQuery框架封装</h1>
<h2 id="-">沙箱模式</h2>
<p>沙箱其实就是一个独立的环境，这个环境中任何的改变，都不会对外部环境产生影响。</p>
<p>函数自调用一样，在自调用函数内部的变量是不会影响到外部的，因此函数自调用模式也叫沙箱模式。</p>
<pre><code class="lang-js">(function(window){

})(window);
</code></pre>
<h2 id="jq-">jq的基本架构</h2>
<pre><code class="lang-js">(function(window,undefined){
    var jQuery = function(){

    }

    // 把jQuery函数暴露到全局中
    window.jQuery = window.$ = jQuery;
})(window);
</code></pre>
<ul>
<li>传参window的作用</li>
</ul>
<p>1、局部区域调用window减少搜索过程</p>
<p>2、有利于代码压缩</p>
<ul>
<li>传参undefined的作用</li>
</ul>
<p>外部取值修改了undefined，防止外部取值的影响，导致兼容性问题</p>
<h2 id="jq-">jq的选择器</h2>
<pre><code class="lang-js">(function(window){
    var jQuery = function(selector){
        // 根据选择器来获取元素
        var ele = document.querySelectorAll(selector);

        // 把获取到的元素遍历添加到jq实例对象上
        for(var i = 0; i &lt; ele.length; i++){
            this[i] = ele[i];
        }
        // 手动维护length属性为获取元素的个数
        this.length = ele.length;
    }

    window.jQuery = window.$ = jQuery;
})(window);
</code></pre>
<p>优化</p>
<pre><code class="lang-javascript">[].push.apply(this,ele);
</code></pre>
<h2 id="-">原型添加方法</h2>
<pre><code class="lang-js">(function(window){
    var jQuery = function(selector){
        // ...
    }

    // 原型替换，给jq原型中添加成员
    jQuery.prototype = {
        constructor: jQuery,
        css: function(){
            // css 操作样式功能...
        },
        html: function(){
            // html 操作文本内容功能...
        },
        //...
    };

    window.jQuery = window.$ = jQuery;
})(window);
</code></pre>
<h2 id="-new-">省去new的操作</h2>
<p>使用工厂函数来省去new可以得到实例对象，方便得到实例对象不用自己手动new</p>
<h2 id="-init-">改变构造函数init的原型</h2>
<p>得到的实例对象访问不到jq原型中的成员，改变init构造函数的原型，使其init的实例对象可以访问的到jq原型中的成员。</p>

          	</article>
        </div>
		</div>
  </body>
</html>
<script type="text/javascript" src="toc/js/jquery-1.4.4.min.js"></script>
<script type="text/javascript" src="toc/js/jquery.ztree.all-3.5.min.js"></script>
<script type="text/javascript" src="toc/js/ztree_toc.js"></script>
<script type="text/javascript" src="toc_conf.js"></script>

<SCRIPT type="text/javascript" >
<!--
$(document).ready(function(){
    var css_conf = eval(markdown_panel_style);
    $('#readme').css(css_conf)
    
    var conf = eval(jquery_ztree_toc_opts);
		$('#tree').ztree_toc(conf);
});
//-->
</SCRIPT>