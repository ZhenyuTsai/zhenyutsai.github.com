<html>
  <head>
	  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>ECMAScript 6</title>
		<link href="toc/style/github-bf51422f4bb36427d391e4b75a1daa083c2d840e.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/style/github2-d731afd4f624c99a4b19ad69f3083cd6d02b81d5.css" media="all" rel="stylesheet" type="text/css"/>
    <link href="toc/css/zTreeStyle/zTreeStyle.css" media="all" rel="stylesheet" type="text/css"/>
    <link rel="shortcut icon" href="favicon.ico" />
    <script src="../js/review.js"></script>
	  <style>
		pre {
		    counter-reset: line-numbering;
		    border: solid 1px #d9d9d9;
		    border-radius: 0;
		    background: #fff;
		    padding: 0;
		    line-height: 23px;
		    margin-bottom: 30px;
		    white-space: pre;
		    overflow-x: auto;
		    word-break: inherit;
		    word-wrap: inherit;
		}

		pre a::before {
		  content: counter(line-numbering);
		  counter-increment: line-numbering;
		  padding-right: 1em; /* space after numbers */
		  width: 25px;
		  text-align: right;
		  opacity: 0.7;
		  display: inline-block;
		  color: #aaa;
		  background: #eee;
		  margin-right: 16px;
		  padding: 2px 10px;
		  font-size: 13px;
		  -webkit-touch-callout: none;
		  -webkit-user-select: none;
		  -khtml-user-select: none;
		  -moz-user-select: none;
		  -ms-user-select: none;
		  user-select: none;
		}

		pre a:first-of-type::before {
		  padding-top: 10px;
		}

		pre a:last-of-type::before {
		  padding-bottom: 10px;
		}

		pre a:only-of-type::before {
		  padding: 10px;
		}

		.highlight { background-color: #ffffcc } /* RIGHT */
		</style>
  </head>
  <body>
	  <div>
				<div style='width:25%;'>
						<ul id="tree" class="ztree" style='width:100%'>

						</ul>
				</div>
        <div id='readme' style='width:70%;margin-left:20%;'>
          	<article class='markdown-body'>
            	<h1 id="-">基本介绍</h1>
<blockquote>
<p>ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。</p>
</blockquote>
<p>我们从node开始，会大量用到ES6中的一些新语法，因此在学习node之前需要先学习一下es6中提供的新语法</p>
<h2 id="ecmascript-javascript-">ECMAScript与Javascript的关系</h2>
<p>ECMAScript，简称ES，是由Ecma国际（欧洲计算机制造商协会,英文名称是European Computer Manufacturers Association）按照标准制定的一种脚本语言规范。</p>
<p>JavaScript是按ECMAScript规范实现的一种脚本语言，JavaScript除了实现了ECMAScript规范，还提供了BOM和DOM的操作。</p>
<h2 id="ecmascript-">ECMAScript版本历史</h2>
<ul>
<li>ES1.0, 1997年06月发布</li>
<li>ES2.0, 1998年06月发布</li>
<li><p>ES3.0, 1999年12月发布</p>
</li>
<li><p>ES4.0,  由于关于语言的复杂性出现了分歧。放弃发布</p>
</li>
<li>ES5.0, 2009年12月发布， 增加了严格模式，增加了少量语法，为ES6铺路</li>
<li>ES6.0, 2015年6月发布，增加了大量的新概念和语法特性<ul>
<li><strong>第六版的名字， 可以叫做ECMAScript6.0(ES), 也可以叫做ECMAScript 2015（ES2015）</strong></li>
<li>ECMA组织决定以后每年6月份都会发布一版新的语法标准，比如ES7(ECMAScript 2016) </li>
<li><strong>通过我们说的ES6泛指ES5之后的下一代标准，涵盖了ES6, ES7, ES8....</strong>  </li>
</ul>
</li>
</ul>
<h1 id="es5-">ES5-数组的新方法</h1>
<h2 id="foreach">forEach</h2>
<p><code>forEach()</code> 方法对数组的每个元素执行一次提供的函数。功能等同于<code>for</code>循环.</p>
<p>应用场景：为一些相同的元素，绑定事件处理器！</p>
<p><strong>需求：遍历数组[&quot;张飞&quot;,&quot;关羽&quot;,&quot;赵云&quot;,&quot;马超&quot;]</strong></p>
<pre><code class="lang-javascript">var arr = [&quot;张飞&quot;,&quot;关羽&quot;,&quot;赵云&quot;,&quot;马超&quot;];
//第一个参数：element，数组的每一项元素
//第二个参数：index，数组的下标
//第三个参数：array，正在遍历的数组
arr.forEach(function(element, index, array){
  console.log(element, index, array);
});
</code></pre>
<p>forEach对比for的好处</p>
<p>1、放置变量的泄露</p>
<p>2、可以结合箭头函数使用<code>arr.forEach（item=&gt;sum+=item）</code></p>
<h2 id="map">map</h2>
<p>map 映射，会遍历一个数组，将每次函数执行结果，存到型数组中</p>
<p><code>map()</code> 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。</p>
<p><strong>需求：遍历数组，求每一项的平方存在于一个数组中</strong></p>
<pre><code class="lang-javascript">var arr = [1,2,3,4,5];  // 1 4 9 16 25
//第一个参数：element，数组的每一项元素
//第二个参数：index，数组的下标
//第三个参数：array，正在遍历的数组
//返回值：一个新数组，每个元素都是回调函数的结果。
var newArray = arr.map(function(element, index, array){
  return element * element;
});
console.log(newArray);//[1,4,9,16,25]
</code></pre>
<h2 id="filter">filter</h2>
<p><code>filter</code>用于过滤掉“不合格”的元素 
如果在回调函数中返回true，那么就留下来，如果返回false，就扔掉</p>
<p>留下的元素会保存到新数组中。</p>
<p><strong>需求：遍历数组，将数组中工资超过5000的值删除[1000, 5000, 20000, 3000, 10000, 800, 1500]</strong></p>
<pre><code class="lang-javascript">var arr = [1000, 5000, 20000, 3000, 10000, 800, 1500];
//第一个参数：element，数组的每一项元素
//第二个参数：index，数组的下标
//第三个参数：array，正在遍历的数组
//返回值：一个新数组，存储了所有返回true的元素
var newArray = arr.filter(function(element, index, array){
  if(element &gt; 5000) {
    return false;
  }else {
    return true;
  }
});
console.log(newArray);//[1000, 5000, 3000, 800, 1500]
</code></pre>
<h2 id="some">some</h2>
<p><code>some</code>用于遍历数组，如果有至少一个满足条件，就返回true，否则返回false。</p>
<p><strong>需求：遍历数组，判断数组是否包含奇数，[2,4,6,8,10,9]</strong></p>
<pre><code class="lang-javascript">var arr = [2,4,6,8,10,21];
//第一个参数：element，数组的每一项元素
//第二个参数：index，数组的下标
//第三个参数：array，正在遍历的数组
//返回值：布尔类型的值，只要有一个回调函数返回true，就返回true
var flag = arr.some(function(element, index, array){
  console.log(element, index, array);
  if(element %2 == 1){
    return true;
  }else {
    return false;
  }
});
console.log(flag);//true
</code></pre>
<h2 id="every">every</h2>
<p><code>every</code>用于遍历数组，只有当所有的元素返回true，才返回true，否则返回false。</p>
<p><strong>需求：遍历数组，判断数组是否都是偶数，[2,4,6,8,10,9]</strong></p>
<pre><code class="lang-javascript">  var arr = [2,4,6,8,10,21];
  //第一个参数：element，数组的每一项元素
  //第二个参数：index，数组的下标
  //第三个参数：array，正在遍历的数组
  //返回值：布尔类型的值，只有当所有的元素返回true，才返回true，否则返回false。
  var flag = arr.every(function(element, index, array){
    console.log(element, index, array);
    if(element %2 == 0){
      return true;
    }else {
      return false;
    }
  });
  console.log(flag);//false
</code></pre>
<h1 id="es6">ES6</h1>
<h2 id="-">变量</h2>
<blockquote>
<p>ES6中提供了两个声明变量的关键字：const和let </p>
</blockquote>
<h3 id="let-">let的使用</h3>
<p>ES6 新增了<code>let</code>命令，用来声明变量。它的用法类似于<code>var</code>。</p>
<ul>
<li>let声明的变量只有在当前作用域有效</li>
</ul>
<pre><code class="lang-js">{
  let a = 10;
  var b = 1;
}

a // ReferenceError: a is not defined.
b // 1
</code></pre>
<ul>
<li>不存在变量提升</li>
</ul>
<pre><code class="lang-js">// let 的情况
console.log(bar); // 报错ReferenceError
let bar = 2;
</code></pre>
<ul>
<li>不允许重复声明</li>
</ul>
<pre><code class="lang-js">let a = 10;
let a = 1;//报错 Identifier &#39;a&#39; has already been declared
</code></pre>
<ul>
<li>块级作用域（全局作用域，局部作用域）</li>
</ul>
<pre><code class="lang-javascript">var age = 20
if(age&gt;180){
    let money = 500
    console.log(money)//外部无法使用money变量
}
console.log(money)//报错，无法找到该变量
</code></pre>
<h3 id="const-">const的使用</h3>
<p><code>const</code>声明一个只读的常量。常量：值不可以改变的量 </p>
<ul>
<li>const声明的量不可以改变</li>
</ul>
<pre><code class="lang-js">const PI = 3.1415;
PI = 3; //报错
</code></pre>
<ul>
<li>const声明的变量必须赋值</li>
</ul>
<pre><code class="lang-js">const num;
</code></pre>
<ul>
<li>如果const声明了一个对象，仅仅保证地址不变</li>
</ul>
<pre><code class="lang-js">const obj = {name:&#39;zs&#39;};
obj.age = 18;//正确
obj = {};//报错
</code></pre>
<ul>
<li>其他用法和let一样</li>
</ul>
<pre><code class="lang-js">1. 只能在当前代码块中使用
2. 不会提升
3. 不能重复声明
</code></pre>
<h3 id="let-const-">let与const的使用场景</h3>
<pre><code class="lang-js">1. 如果声明的变量不需要改变，那么使用const
2. 如果声明的变量需要改变，那么用let
3. 学了const和let之后，尽量别用var
3. 复杂数据类型都需要使用const
</code></pre>
<h2 id="-">解构赋值</h2>
<blockquote>
<p>可以从对象或者数组中解构出值，赋值给变量。</p>
</blockquote>
<h3 id="-">数组解构</h3>
<p>以前，为变量赋值，只能直接指定值。</p>
<pre><code class="lang-javascript">let a = 1;
let b = 2;
let c = 3;
</code></pre>
<p>ES6 允许写成下面这样。</p>
<pre><code class="lang-javascript">let [a, b, c] = [1, 2, 3];
consoel.log(a,b,c);
//不需要前面的元素可以使用，
let [, b, c] = [1, 2, 3];
consoel.log(b,c);
</code></pre>
<p>解构默认值</p>
<pre><code class="lang-js">let [a = 0, b, c] = [1, 2, 3];
</code></pre>
<h3 id="-">对象解构</h3>
<p>解构不仅可以用于数组，还可以用于对象。</p>
<pre><code class="lang-javascript">let { foo, bar } = { foo: &#39;aaa&#39;, bar: &#39;bbb&#39; };
foo // &quot;aaa&quot;
bar // &quot;bbb&quot;
</code></pre>
<p>如果变量名与属性名不一致，可以使用：</p>
<blockquote>
<p>定义变量与对象中属性不一样的名字</p>
</blockquote>
<pre><code class="lang-javascript">let { foo: baz } = { foo: &#39;aaa&#39;, bar: &#39;bbb&#39; };
baz // &quot;aaa&quot;

let obj = { first: &#39;hello&#39;, last: &#39;world&#39; };
let { first: f, last: l } = obj;
f // &#39;hello&#39;
l // &#39;world&#39;
</code></pre>
<p>解构时需要指定默认值，可以使用=</p>
<blockquote>
<p>默认值：是值对象中没有该属性的值，使用默认值，如果有值使用对象中的属性值</p>
</blockquote>
<pre><code class="lang-js">const obj = {
    name:&quot;zs&quot;,
    age:18
}
const {name,age,desc = &quot;不错&quot;}=obj
</code></pre>
<h3 id="-">函数参数的解构</h3>
<p>函数的参数也可以使用解构赋值。</p>
<pre><code class="lang-javascript">function fn({name,age},money){
  console.log(name,age,money)
}
const obj ={
    name:&quot;zs&quot;,
    age:18
}
fn(obj,100)
</code></pre>
<h2 id="-">字符串</h2>
<h3 id="-">模版字符串</h3>
<p>传统的 JavaScript 语言，输出模板通常是这样写的（下面使用了 jQuery 的方法）。</p>
<pre><code class="lang-javascript">$(&#39;#result&#39;).append(
  &#39;There are &lt;b&gt;&#39; + basket.count + &#39;&lt;/b&gt; &#39; +
  &#39;items in your basket, &#39; +
  &#39;&lt;em&gt;&#39; + basket.onSale +
  &#39;&lt;/em&gt; are on sale!&#39;
);
</code></pre>
<p>上面这种写法相当繁琐不方便，ES6 引入了模板字符串解决这个问题。<strong>反引号：<code></code></strong></p>
<pre><code class="lang-javascript">$(&#39;#result&#39;).append(`
  There are &lt;b&gt;${basket.count}&lt;/b&gt; items
   in your basket, &lt;em&gt;${basket.onSale}&lt;/em&gt;
  are on sale!
`);
</code></pre>
<p>字符串模版的优点</p>
<ul>
<li>允许换行</li>
<li>可以使用插值  <code>${变量名}</code></li>
</ul>
<h3 id="-">字符串方法</h3>
<p><strong>es5新增方法</strong></p>
<ul>
<li><strong>includes()</strong>：返回布尔值，表示是否找到了参数字符串。</li>
<li><strong>startsWith()</strong>：返回布尔值，表示参数字符串是否在原字符串的头部。</li>
<li><strong>endsWith()</strong>：返回布尔值，表示参数字符串是否在原字符串的尾部。</li>
</ul>
<h2 id="-">数组</h2>
<h3 id="find">find</h3>
<p><strong>find是ES6新增的语法</strong></p>
<p><code>find()</code> 方法返回数组中满足提供的测试函数的第一个<strong>元素的值</strong>。否则返回 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined"><code>undefined</code></a>。 </p>
<pre><code class="lang-js">// 获取第一个大于10的数
var array1 = [5, 12, 8, 130, 44];

var found = array1.find(function(element) {
  return element &gt; 10;
});
console.log(found);
</code></pre>
<h3 id="findindex">findIndex</h3>
<p><strong>findIndex是ES6新增的语法</strong></p>
<p><code>findIndex()</code>方法返回数组中满足提供的测试函数的第一个<strong>元素的索引</strong>。否则返回-1。 </p>
<pre><code class="lang-js">// 获取第一个大于10的下标
var array1 = [5, 12, 8, 130, 44];

function findFirstLargeNumber(element) {
  return element &gt; 13;
}

console.log(array1.findIndex(findFirstLargeNumber));
</code></pre>
<h2 id="-">函数-箭头函数</h2>
<p>ES6标准新增了一种新的函数：Arrow Function（箭头函数）。</p>
<p>为什么叫Arrow Function？因为它的定义用的就是一个箭头：</p>
<h3 id="-">基本使用</h3>
<pre><code class="lang-js">var fn = function(x, y) {
    console.log(x + y);
}

相当于
//语法： (参数列表) =&gt; {函数体}
var fn = (x, y) =&gt; {
    console.log(x + y);
}
</code></pre>
<h3 id="-">参数详解</h3>
<ul>
<li>如果没有参数列表，使用()表示参数列表</li>
</ul>
<pre><code class="lang-js">var sum = () =&gt; {
    console.log(&#39;哈哈&#39;)
};
// 等同于：
var sum = function() {    
    console.log(&#39;哈哈&#39;)
};
</code></pre>
<ul>
<li>如果只有一个参数，可以省略()</li>
</ul>
<pre><code class="lang-js">// 等同于：
var sum = function(n1) {    
    console.log(&#39;哈哈&#39;)
};

var sum = n1 =&gt; {
    console.log(&#39;哈哈&#39;)
};

</code></pre>
<ul>
<li>如果有多个参数，需要使用()把参数列表括起来</li>
</ul>
<pre><code class="lang-js">var sum = function(n1, n2) {    
    console.log(&#39;哈哈&#39;)
};

var sum = (n1, n2) =&gt; {
    console.log(&#39;哈哈&#39;)
};
</code></pre>
<h3 id="-">返回值详解</h3>
<ul>
<li>如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来</li>
</ul>
<pre><code class="lang-js">var sum = function(n1) {    
    console.log(&#39;哈哈&#39;)
};

var sum = n1 =&gt; {
    console.log(&#39;哈哈&#39;)
};
</code></pre>
<ul>
<li>如果函数体只有一行一句，那么可以省略{}和return</li>
</ul>
<pre><code class="lang-js">var fn = function(n1, n2) {
    return n1 + n2;
}

var fn = (n1, n2) =&gt; n1 + n2;
</code></pre>
<h3 id="-">案例</h3>
<ol>
<li>有一个数组<code>[1,3,5,7,9,2,4,6,8,10]</code>,请对数组进行排序</li>
<li>有一个数组<code>[&#39;a&#39;,&#39;ccc&#39;,&#39;bb&#39;,&#39;dddd&#39;]</code>,请按照字符串长度对数组进行排序</li>
<li>有一个数组，<code>[57,88,99,100,33,77]</code>,请保留60分以上的成绩，返回一个新的数组</li>
</ol>
<h3 id="-">箭头函数的注意点</h3>
<h4 id="this-">this指向</h4>
<ol>
<li>箭头函数内部没有this，因此箭头函数内部的this指向了外部的this</li>
<li>箭头函数不能作为构造函数和事件绑定，因为箭头函数没有this</li>
<li>定时器和延时器一律使用箭头函数简化</li>
</ol>
<p>【定义一个对象，定时器打招呼】</p>
<p><strong>苦口婆心一下：箭头函数刚开始用，肯定会有点不习惯，但是任何东西都有一个习惯的过程，慢慢接受就好了，多用，多练</strong></p>
<h4 id="-">函数参数</h4>
<p><strong>默认参数</strong></p>
<p>ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。</p>
<pre><code class="lang-javascript">function log(x, y = &#39;World&#39;) {
  console.log(x, y);
}

log(&#39;Hello&#39;) // Hello World
log(&#39;Hello&#39;, &#39;China&#39;) // Hello China
log(&#39;Hello&#39;, &#39;&#39;) // Hello
</code></pre>
<p><strong>rest参数</strong>(剩余参数)</p>
<pre><code class="lang-javascript">function add(...values) {

}
//收集所有没有使用的参数，是一个数组
add(2, 5, 3) // 10
</code></pre>
<h2 id="-">对象</h2>
<h3 id="-">简写</h3>
<p>属性简写</p>
<pre><code class="lang-js">const user = &#39;zs&#39;
const age = 18
const obj = {
    name: username,
    age
}
</code></pre>
<p>方法简写</p>
<pre><code class="lang-js">const obj = {
    name: username,
    age,
    sayHi(){
        console.log(&quot;hi&quot;)
    }
}
</code></pre>
<h3 id="-">展开运算符</h3>
<p><strong>数组</strong></p>
<p>展开运算符可以展开一个数组或者对象</p>
<pre><code class="lang-js">const arr = [1,2,3,4,5]
console.log(...arr)=&gt;console.log(1,2,3,4,5)
</code></pre>
<p>展开一个数组，用于数组拼接</p>
<pre><code class="lang-js">const arr1 = [1,2,3]
const arr2 = [4,5,6]
const newArr=[...arr1,..arr2]
</code></pre>
<p>求数组最大值</p>
<pre><code class="lang-js">const arr=[1,2,3]
const max=Math.max(...arr)
</code></pre>
<p><strong>对象</strong></p>
<p>展开一个对象，用于对象拼接</p>
<pre><code class="lang-js">const obj1={
    car:&quot;老师来说&quot;
}
const obj2={
    name:&quot;牛牛&quot;
}
const newObj={
    ...obj1,
    ...obj2
}
</code></pre>
<h2 id="set-">set集合</h2>
<p>用于数组去重</p>
<pre><code class="lang-js">const arr = [1,2,2,3,4,4,5,99,99]
//去除重复
const s = new Set(arr)
//将重复项转换为数组
const arr = [...s]
</code></pre>
<h1 id="promise">promise</h1>
<h2 id="-">异步与回调函数的说明</h2>
<p>回调函数:</p>
<ol>
<li><p>把一个函数当成参数传递, 将来特定的时机调用, 这个函数就叫回调函数</p>
</li>
<li><p>什么时候会用到回调函数, 异步的时候   (定时器, 延时器, ajax   success 和  error)</p>
<pre><code class="lang-js"> console.log(1)

 setTimeout(function() {
     console.log(2)

     setTimeout(function() {
         console.log(4)
     }, 2000)

     console.log(5)

 }, 2000)

 console.log(3)
</code></pre>
</li>
</ol>
<p>回调函数的问题:</p>
<ol>
<li>回调函数的阅读性不好, 回调不会立马执行</li>
<li>回调函数如果大量的嵌套, 可维护性差  (回调地狱)</li>
</ol>
<h2 id="-">回调函数的嵌套问题</h2>
<p>按照顺序依次读取 - a, b, c, d 四个文件</p>
<p>回调地狱: 回调函数嵌套回调函数, 嵌套多了, 将来就很难维护, 很难理清顺序</p>
<h2 id="promise-">promise 的基本语法</h2>
<p>目的: promise 是书写异步代码的另一种方式, 解决回调函数嵌套的问题</p>
<ol>
<li><p>如何创建一个 promise 对象</p>
<pre><code class="lang-js"> const p = new Promise((resolve, reject) =&gt; {
     promise内部会封装一个异步操作
     成功调用 resolve
     失败调用 reject
 })
</code></pre>
</li>
<li><p>如何使用一个 promise 对象</p>
<pre><code class="lang-js"> 2. 使用 promise 对象
   .then(res =&gt; { ... }) 处理成功
   .catch(res =&gt; { ... }) 处理失败
</code></pre>
</li>
</ol>
<h2 id="promise-">promise 解决回调地狱的问题</h2>
<p><strong>如果有多个 promise 需要处理, 支持链式编程</strong></p>
<pre><code class="lang-js">const p = new Promise(function (resolve, reject) {
  // promise 内部会封装一个异步的操作
  // resolve: 成功的时候, 需要调用
  // reject: 失败的时候, 需要调用
  fs.readFile(&#39;a.txt&#39;, &#39;utf8&#39;, (err, data) =&gt; {
    if (err) {
      reject(err)
    } else {
      resolve(data)
    }
  })
})
const p2 = new Promise(function (resolve, reject) {
  fs.readFile(&#39;b.txt&#39;, &#39;utf8&#39;, (err, data) =&gt; {
    if (err) {
      reject(err)
    } else {
      resolve(data)
    }
  })
})
....

p.then(res =&gt; {
  console.log(res)
  return p2
}).then(res =&gt; {
  console.log(res)
  return p3
}).then(res =&gt; {
  console.log(res)
  return p4
}).then(res =&gt; {
  console.log(res)
}).catch(err =&gt; {
  console.log(err)
})
</code></pre>
<p><strong>基本用法</strong></p>
<pre><code class="lang-js">function read (filename) {
  return new Promise(function (resolve, reject) {
    // promise 内部会封装一个异步的操作
    // resolve: 成功的时候, 需要调用
    // reject: 失败的时候, 需要调用
    fs.readFile(filename, &#39;utf8&#39;, (err, data) =&gt; {
      if (err) {
        reject(err)
      } else {
        resolve(data)
      }
    })
  })
}

read(&#39;a.txt&#39;).then(res =&gt; {
  console.log(res)
  return read(&#39;b.txt&#39;)
}).then(res =&gt; {
  console.log(res)
  return read(&#39;c.txt&#39;)
}).then(res =&gt; {
  console.log(res)
  return read(&#39;d.txt&#39;)
}).then(res =&gt; {
  console.log(res)
}).catch(err =&gt; {
  console.log(err)
})
</code></pre>
<h2 id="promise-">Promise常用的几个方法说明</h2>
<ul>
<li><code>Promise.resolve()</code><ul>
<li>用法：<code>Promise.resolve( 成功的数据 )</code></li>
<li>直接得到一个成功的 Promise</li>
</ul>
</li>
<li><p><code>Promise.reject()</code></p>
<ul>
<li>用法：<code>Promise.reject( 失败的原因 )</code></li>
<li>直接得到一个失败的 Promise</li>
</ul>
</li>
<li><p><code>Promise.all([promise1, promise2, promise3, ...])</code></p>
<ul>
<li>作用：all 方法会在所有的 promise 参数全部成功之后，再执行 .then</li>
</ul>
</li>
</ul>
<pre><code class="lang-js">Promise.all([
  axios.get(&#39;接口1&#39;),
  axios.get(&#39;接口2&#39;),
  axios.get(&#39;接口3&#39;),
]).then(res =&gt; {
  // 当此处的代码执行的时候， 三个 axios 请求，已经全部完成了
  // 此时， res =&gt; [ 接口1的结果, 接口2的结果, 接口3的结果 ]
})
</code></pre>
<ul>
<li><code>Promise.race([promise1, promise2, promise3, ...])</code> - 竞速<ul>
<li>作用： 只要有一个 promise 完成了， 就会执行 .then 方法</li>
</ul>
</li>
</ul>
<pre><code class="lang-js">Promise.race([
  axios.get(&#39;接口1&#39;),
  axios.get(&#39;接口2&#39;),
  axios.get(&#39;接口3&#39;),
]).then(res =&gt; {
  // 只要一个 axios 接口返回数据了，就会执行此处的代码
  // 此时， res =&gt; 表示最先完成的 axios 的结果
})
</code></pre>
<h1 id="async-await">async 和 await</h1>
<h2 id="async-await-">async 和 await 解决回调问题</h2>
<p>async 和 await 是一对关键字</p>
<ol>
<li><p>async用于修饰一个函数, 表示一个函数是异步的</p>
</li>
<li><p>await 用于等待一个成功结果, 只能用在 async 函数中</p>
</li>
<li><p>await 后面一般会跟一个promise对象,  await会阻塞async函数的执行, 直到等到了 promise成功的结果(resolve的结果)</p>
</li>
<li><p>await 只会等待 promise 成功的结果, 如果失败了会报错, 需要 try catch</p>
</li>
</ol>
<h2 id="-async-await-">使用 async 和 await 去优化代码</h2>
<ol>
<li>修改状态的优化</li>
<li>删除的<code>$confirm</code> 和删除ajax功能的优化</li>
<li>获取功能的优化</li>
<li>登录: 表单校验 和 登录ajax请求优化</li>
</ol>

          	</article>
        </div>
		</div>
  </body>
</html>
<script type="text/javascript" src="toc/js/jquery-1.4.4.min.js"></script>
<script type="text/javascript" src="toc/js/jquery.ztree.all-3.5.min.js"></script>
<script type="text/javascript" src="toc/js/ztree_toc.js"></script>
<script type="text/javascript" src="toc_conf.js"></script>

<SCRIPT type="text/javascript" >
<!--
$(document).ready(function(){
    var css_conf = eval(markdown_panel_style);
    $('#readme').css(css_conf)
    
    var conf = eval(jquery_ztree_toc_opts);
		$('#tree').ztree_toc(conf);
});
//-->
</SCRIPT>